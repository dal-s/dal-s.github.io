<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Go系列(六):sync/atomic和mutex]]></title>
    <url>%2F2018%2F12%2F18%2FGo%E7%B3%BB%E5%88%97-%E5%85%AD-atomic%E5%92%8Cmutex%2F</url>
    <content type="text"><![CDATA[atomic和mutex是两种实现多线程之间通信的方式。以下我们找两段代码分别展示其用法。 sync/atomic很多场景中，我们要统计线程执行次数，此时我们需要一个简单计数器。12345678910111213141516171819202122func t_atomic_counter() &#123; var ops uint64 //go 10 threds and run 2 second for i := 0; i &lt; 10; i++ &#123; go func() &#123; for &#123; atomic.AddUint64(&amp;ops, 1) time.Sleep(time.Millisecond) &#125; &#125;() &#125; // time is end,thred is end time.Sleep(time.Second * 2) opsFinal := atomic.LoadUint64(&amp;ops) fmt.Println("ops:", opsFinal)&#125; 上面的代码调起了10个线程，执行相关业务代码，同时在线程中的for循环中调用AddUint64对ops做加1的操作。在main函数中，我们主动sleep了2秒，然后获取ops的值，看看我们在2秒内执行了多少次循环。这是一个简单的多个线程共同操作一个计数器的示例。更复杂一点的，多个线程同时修改我们自己定义的变量呢？此时我们需要用到锁的机制了，来一起看下下面的代码。 mutexmutex是互斥锁，在很多编程语言中都有用到，是控制多线程同时访问同意变量的常用手段之一。来一段实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051func t_mutexes() &#123; var state = make(map[int]int) var mutex = &amp;sync.Mutex&#123;&#125; var readOps uint64 var writeOps uint64 for r := 0; r &lt; 10; r++ &#123; go func() &#123; total := 0 for &#123; key := rand.Intn(5) mutex.Lock() total += state[key] mutex.Unlock() atomic.AddUint64(&amp;readOps, 1) time.Sleep(2 * time.Millisecond) &#125; &#125;() &#125; for w := 0; w &lt; 5; w++ &#123; go func() &#123; for &#123; key := rand.Intn(5) val := rand.Intn(999) mutex.Lock() state[key] = val mutex.Unlock() atomic.AddUint64(&amp;writeOps, 1) time.Sleep(2 * time.Millisecond) &#125; &#125;() &#125; time.Sleep(3 * time.Second) readOpsFinal := atomic.LoadUint64(&amp;readOps) fmt.Println("readOps:", readOpsFinal) writeOpsFinal := atomic.LoadUint64(&amp;writeOps) fmt.Println("writeOps:", writeOpsFinal) /*no uesed.emmm....*/ //mutex.Lock() //确保主线程可以获取到锁 fmt.Println("state:", state) //mutex.Unlock()&#125; 代码最开始，先声明了几个变量，两个计数器、一个互斥锁，一个map。然后用100个线程取求state这个map中值得和，用10个线程取填充state这个map。在两个线程中，会出现同时操作state这个map的时刻，因此在操作之前要分别加锁，先获取锁，再操作state，然后再释放锁，以此来保证同一时刻只有一个线程拥有操作state的权限。这段代码中也用到了atomic的方法来记录我们读\写的次数。但是这种方法效率有时候并非很高，可能很多资源都用在了争锁上，尤其是单机运行时，这种情况会更明显。当然，也有更好的解决办法，比如我们读的时候用只读锁等等。 简单复习了两种多线程之间的通信方法，更复杂的以后再继续更新。下一节要复习interface这个特殊的类型。interface是一种特别的数据类型，在golang的源码中可以说是遍地都是，下一节我们一起来学习这个神奇的类型。]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go系列(五):Goroutines]]></title>
    <url>%2F2018%2F12%2F12%2FGo%E7%B3%BB%E5%88%97-%E4%BA%94-Goroutines%2F</url>
    <content type="text"><![CDATA[并发编程是golang基因中就支持的特性，而且十分的方便好用，很多其他编程语言中的并发控制和通讯都及其便捷。 关键字gogolang中调用函数1234f() //call f() ;wait for it to returngo f() //go的线程来了（严格说和线程是有区别的，姑且这么叫着），不等f函数的返回 golang的并发编程就是这么简单，本节完。等等…还有一点。 多线程之间的通信之channel无缓冲channel的每次发送和接收发生在不同的线程中，由此来达到数据同步或通信的目的。来一段实例12345678package mainimport "fmt"func main() &#123; messages := make(chan string) go func() &#123; messages &lt;- "ping" &#125;() msg := &lt;-messages fmt.Println(msg)&#125; 上面的一小段示例用到了匿名函数，函数体很简单，向messages中写入一个字符串，然后再main中读取出来。这样主线程和go调起来的线程就进行了一次简单的数据同步动作。 再来，我们用channel来实现等待线程结束，然后主线程退出的功能。 123456go func() &#123; //do something..... done &lt;- true&#125;()&lt;-done //阻塞等待子线程完成 go调起来的线程可以做很多事情，只要退出前向管道中写入字符串表示工作完成，然后在主线程中读出字符串。 再来，来一个线程池，同时并发多个子线程完成工作。 123456789101112131415161718192021222324252627282930313233func t_worker_pool(id int, jobs &lt;-chan int, results chan&lt;- int) &#123; for j := range jobs &#123; fmt.Println("worker", id, "started job", j) time.Sleep(time.Second) fmt.Println("worker", id, "finished job", j) results &lt;- j * 1 &#125;&#125;func t_pool() &#123; jobs := make(chan int, 100) results := make(chan int, 100) //thread nums for w := 1; w &lt;= 7; w++ &#123; go t_worker_pool(w, jobs, results) &#125; //job nums for j := 1; j &lt;= 20; j++ &#123; jobs &lt;- j &#125; close(jobs) for a := 1; a &lt;= 20; a++ &#123; &lt;-results // ensure all jobs is finished &#125;&#125; t_pool 函数中调起7个子线程，完成job，并接受其返回的结果。t_worker_pool 是其具体实现，循环读出jbos队列中的信息，然后将结果写入results。t_pool第二个for循环，作用是分配20个job，分配完成后关闭jobs队列。 然后循环等待所有results都被写入内容。实现了使用7个线程完成20个job的功能。 多线程之间通信，除了channel还有sync/atomic包实现多线程共享变量，以及 mutex 实现更复杂的多线程之间变量互相访问，这些内容我们下一节再聊。]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go系列(四):函数和方法]]></title>
    <url>%2F2018%2F12%2F04%2FGo%E7%B3%BB%E5%88%97-%E5%9B%9B-%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[主要介绍golang的函数，包括声明方式、多返回值特性、匿名函数等。 函数的声明我们从源码里粘一段声明出来示例。1234func Reverse(data Interface) Interface &#123; return &amp;reverse&#123;data&#125;&#125; 这是sort函数中的一段反转字符串的代码，其中func是关键字、Reverse是函数名、data 是入参名、括号内的Interface是入参的类型、括号外的Interface是返回值得类型。以上就是构成一段完整的函数声明需要的所有元素。 函数名称大小写的问题，可以参考golang代码规范。 其中入参和返回值的类型可以是任何合法的数据类型，结构体、数组、slice、map、channel、int、string等等。 来，接下来我们粘一段方法的声明方式，很相似，所以放在一起看一下，防止概念不清楚。 1234// Less returns the opposite of the embedded implementation\'s Less method.func (r reverse) Less(i, j int) bool &#123; return r.Interface.Less(j, i)&#125; 来一起看Less这个方法的声明，同样有入参、返回值、方法名、与函数唯一不同的地方在于，方法名前有r reverse，这个r的含义是，该方法是被reverse类型的变量调用调用方法如下：123456789101112131415type reverse struct &#123; // This embedded Interface permits Reverse to use the methods of // another Interface implementation. Interface&#125;func IsSorted(data Interface) bool &#123; n := data.Len() for i := n - 1; i &gt; 0; i-- &#123; if data.Less(i, i-1) &#123; return false &#125; &#125; return true&#125; 看data.Less，这里data是一种特殊的数据类型–接口，我们在以后再细说。如果这个例子不太形象，我们再来看下一个，出自golang在线教程中的一段代码。12345678910111213type rect struct&#123; width,height int&#125;func (r *rect) area() int&#123; return r.width*r.height&#125;func t_main() &#123; r := rect&#123;width:10,height:5&#125; fmt.Println(r.area())&#125; rect是一个结构体，r := rect{width:10,height:5} 定义了r是rect结构体，并为他的成员分别赋值10和5,r.area() 调用area这个方法，计算面积。这个例子应该很形象了，如果我定义一个int型数组的变量来调用该方法呢。1234567func main() &#123; r := rect&#123;width:10,height:5&#125; a := []int&#123;1,2&#125; fmt.Println(a.area())&#125;# command-line-arguments./hi.go:17:18: a.area undefined (type []int has no field or method area) 会报undefined的错误，解释为我们没有给int数组定义一个area的方法，所以不能调用。 方法和函数的区别到这里应该清楚了，下面看几个golang函数的特性。 多返回值多返回值和defer是golang设计的神来之笔，太牛了，golang函数一般会返回两个值，一个是期望得到的返回值，一个是错误信息，我们继续扒源码看一下。 1234567891011func (s *SectionReader) Read(p []byte) (n int, err error) &#123; if s.off &gt;= s.limit &#123; return 0, EOF &#125; if max := s.limit - s.off; int64(len(p)) &gt; max &#123; p = p[0:max] &#125; n, err = s.r.ReadAt(p, s.off) s.off += int64(n) return&#125; 这是io中的一段源码，Read函数返回了两个值，一个是读的字节数n，一个是错误信息err，接收也很简单，就像n, err = s.r.ReadAt(p, s.off) 这个函数一样，一个变量接收字节数，另外一个变量接收错误信息，如果不需要错误信息，也可以用丢弃变量 n, _ = s.r.ReadAt(p, s.off)。 这个设计妙在既可以又可以的地方，比如写入文件，也会返回两个变量，写入字节数和错误信息，我们完全可以得到已经写入多少字节，以及出现了什么错误。写到这里，我想到断点续传的功能，用golang实现可以说是非常简单了。 匿名函数匿名函数，并不是golang的特权，python的lambda也是类似的功能。来一起看一下 12345678func (p *pipe) CloseRead(err error) error &#123; if err == nil &#123; err = ErrClosedPipe &#125; p.rerr.Store(err) p.once.Do(func() &#123; close(p.done) &#125;) return nil&#125; 上面这段代码中 p.once.Do(func() { close(p.done) }) 包含一段匿名函数，有func关键字，没有函数名称{}包围了实现功能。类似这样的用法就叫匿名函数 可变参数可变参数也不是golang独有的特性，其中C语言中也有类似的实现。不过c语言的可变参数是通过一个系统定义好的数组存储的，golang可以直接自己用循环遍历。最常用恐怕就是fmt中的println函数了，我们来扒一下它的源代码。 1234567891011121314151617181920212223// Fprint formats using the default formats for its operands and writes to w.// Spaces are added between operands when neither is a string.// It returns the number of bytes written and any write error encountered.func Fprint(w io.Writer, a ...interface&#123;&#125;) (n int, err error) &#123; p := newPrinter() p.doPrint(a) n, err = w.Write(p.buf) p.free() return&#125;func (p *pp) doPrint(a []interface&#123;&#125;) &#123; prevString := false for argNum, arg := range a &#123; isString := arg != nil &amp;&amp; reflect.TypeOf(arg).Kind() == reflect.String // Add a space between two non-string arguments. if argNum &gt; 0 &amp;&amp; !isString &amp;&amp; !prevString &#123; p.buf.WriteByte(' ') &#125; p.printArg(arg, 'v') prevString = isString &#125;&#125; 其中 a …interface{} 表示是个可变的参数，且是接口，又看到了这个特殊的类型，我们继续跳过，假装它是一个普通的数据类型就好。在doPrint中用for argNum, arg := range a循环变脸参数列表，argNum表示参数下表，arg是参数值。 以上是可变参数函数的定义和使用的基本方式。 defer panic recoverdefer是golang另外一个神技，defer后跟的语句，在运行结束的最后才运行，经常用在释放资源、关闭文件等操作。大大减少了代码中到处的错误检查和资源释放。 123456789101112131415161718192021222324252627282930313233func (fs *fileStat) loadFileId() error &#123; fs.Lock() defer fs.Unlock() //当函数运行结束时，释放锁 if fs.path == "" &#123; // already done return nil &#125; var path string if fs.appendNameToPath &#123; path = fs.path + `\` + fs.name &#125; else &#123; path = fs.path &#125; pathp, err := syscall.UTF16PtrFromString(path) if err != nil &#123; return err &#125; h, err := syscall.CreateFile(pathp, 0, 0, nil, syscall.OPEN_EXISTING, syscall.FILE_FLAG_BACKUP_SEMANTICS, 0) if err != nil &#123; return err &#125; defer syscall.CloseHandle(h) //当函数运行结束时，关闭文件句柄 var i syscall.ByHandleFileInformation err = syscall.GetFileInformationByHandle(h, &amp;i) if err != nil &#123; return err &#125; fs.path = "" fs.vol = i.VolumeSerialNumber fs.idxhi = i.FileIndexHigh fs.idxlo = i.FileIndexLow return nil&#125; 释放资源的语句紧跟在资源获取语句之后，后面无论代码如何运行还是报错等等，defer语句都会在最后执行。其余的错误判断中无需做任何特殊处理。 panic 实现类似asset的功能，报错直接退出，但是它的报错信息不是特别友好，简单看下它的使用方法。1234567891011121314151617181920func init() &#123; if e := os.Getenv(executable_EnvVar); e != "" &#123; // first chdir to another path dir := "/" if runtime.GOOS == "windows" &#123; cwd, err := os.Getwd() if err != nil &#123; panic(err) //报错退出 &#125; dir = filepath.VolumeName(cwd) &#125; os.Chdir(dir) if ep, err := os.Executable(); err != nil &#123; fmt.Fprint(os.Stderr, "ERROR: ", err) &#125; else &#123; fmt.Fprint(os.Stderr, ep) &#125; os.Exit(0) &#125;&#125; 由于panic报错信息很不友好，我们又有了recover函数，用来恢复现场，恢复错误发生时的堆栈信息，还原错误场景。recover通常和defer一起使用，当程序崩溃的时候触发 12345678func TestNewTickerLtZeroDuration(t *testing.T) &#123; defer func() &#123; if err := recover(); err == nil &#123; t.Errorf("NewTicker(-1) should have panicked") &#125; &#125;() NewTicker(-1)&#125; 当defer函数发生了panic异常，recover会使程序从panic中恢复，并返回panic value。导致panic异常的函数不会继续运行，但能正常返回。在未发生panic异常时调用recover，会返回nil。以上是golang一些特殊的技能，下一节一起来看看golang最强的goroutines]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go系列(三):new和make]]></title>
    <url>%2F2018%2F11%2F29%2FGo%E7%B3%BB%E5%88%97-%E4%B8%89-new%E5%92%8Cmake%2F</url>
    <content type="text"><![CDATA[make 和 new 都用作初始化变量，区别有以下几点。 原型分别如下：1234567891011121314151617181920212223// The new built-in function allocates memory. The first argument is a type,// not a value, and the value returned is a pointer to a newly// allocated zero value of that type.func new(Type) *Type// The make built-in function allocates and initializes an object of type// slice, map, or chan (only). Like new, the first argument is a type, not a// value. Unlike new, make's return type is the same as the type of its// argument, not a pointer to it. The specification of the result depends on// the type:// Slice: The size specifies the length. The capacity of the slice is// equal to its length. A second integer argument may be provided to// specify a different capacity; it must be no smaller than the// length. For example, make([]int, 0, 10) allocates an underlying array// of size 10 and returns a slice of length 0 and capacity 10 that is// backed by this underlying array.// Map: An empty map is allocated with enough space to hold the// specified number of elements. The size may be omitted, in which case// a small starting size is allocated.// Channel: The channel's buffer is initialized with the specified// buffer capacity. If zero, or the size is omitted, the channel is// unbuffered.func make(t Type, size ...IntegerType) Type 主要区别： make将变量值初始化为0，而new只是为变量分配了一块内存，返回指向分配地址的指针； 使用范围不同，make用在slice、channel、map（slice、channel、map 只有在初始化后，才可以使用），new可以给所有类型分配空间 eg:1234567891011121314v := make(map[string] string) //声明一个mapv := make([]string,10) //声明一个slicev := make(chan string) //声明一个channelnew的示例type T_new struct &#123; name,sex string&#125;三种方式都能正常使用r1 := new(T_new) // &amp;&#123; &#125;r2 := &amp;T_new&#123;"a","b"&#125; // &amp;&#123;a b&#125;r3 := T_new&#123;name:"a",sex:"b"&#125; // &#123;a,b&#125;r4 := T_new("a","b") // &#123;a,b&#125; make和new是容易混淆的概念，其实把函数原型放出来看一下，就明白了两者的区别，放一起比较使用，会更清晰一点，下一节写 函数声明和方法声明]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go系列(二):数组 map slice]]></title>
    <url>%2F2018%2F11%2F27%2FGo%E7%B3%BB%E5%88%97-%E4%BA%8C-%E6%95%B0%E7%BB%84%20map%20slice%2F</url>
    <content type="text"><![CDATA[golang 中数组、slice、map都属于collection类型，大概就是分出一片空间存储一堆的数据。 他们的主要区别： 数组有长度，slice没有， map是无序的，数组和slice有序 数组和slice下标数数字，map的key是任意等值性类型 数组的三种声明方式:123456var i [10]inti[0]=1var i=[10]inti:=[10]int 数组是值，数组间复制相当于复制了一个数组副本数组作为参数传入函数，函数收到的也是数组的副本，而非指针（地址）数组的大小是类型声明的一部分，不可或缺 slice的声明方式： 1234567891011var i []int //这里的i就是没有长度的slice了初始化:var i []type=make([]type,len) //len是切片的初始长度或i := make([]type,len)i :=[] int&#123;1,2,3&#125;i := arr[:] //arr是一个数组 :两侧可以写数组下标，表示数字的0~len的值Tips:make 和new 都是初始化slice的一种方式，他们的区别下一节再写 map的声明方式:12345678var i_map map[key_type]value_typevar i map[string]int //声明了一个map，但还无法使用，必须初始化以后才能使用i=make(map[string]int) //初始化map，初始化后才可以存储数据i_map := make(map[string]int) //另一种方式，省略var关键字，但是只可以在函数内部使用i_map :=map[string]int&#123;"key1":1,"key2":2&#125; //直接初始化使用 今天用了make方式初始化了slice和map，golang中还有new方法也是初始化变量，其中某些区别下一节再细聊。]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go系列(一):变量声明]]></title>
    <url>%2F2018%2F11%2F26%2FGo%E7%B3%BB%E5%88%97-%E4%B8%80-%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%2F</url>
    <content type="text"><![CDATA[golang 整体看起来像是like c风格，常用变量类型有 1int string array map slice 等 变量声明方式有以下三种： 1、var 变量名 变量类型 (可用作全局变量声明) 2、var 变量名 = value，自行判定变量类型 3、省略var 变量名:=value，自行判定变量类型，只能用于函数内部，不可用作全局变量声明 示例:123456var i_int int i_int=3var i_int=3i_int:=3 多变量声明123456789101112var name1 name2 name3 type name1,name2,name3 = v1,v2,v3(var name1 type1=v1)var name1,name2,name3 = v1,v2,v3name1,name2,name3 :=v1,v2,v3var ( name1 type1 name2 type2) //常用语全局变量声明 特殊变量 _常用语接收代码不需要的变量，是一个only read 变量，如果代码中某个变量声明但未使用，代码编译会报错，这时可以使用_接收变量，绕过这个error。12345func main()&#123; var a int =1 //fmt.Println(a) _ =a&#125; 下一节：array、map、slice的使用]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F11%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[E大博文链接合集]]></title>
    <url>%2F2018%2F11%2F26%2FE%E5%A4%A7%E5%8D%9A%E6%96%87%E9%93%BE%E6%8E%A5%E5%90%88%E9%9B%86%2F</url>
    <content type="text"><![CDATA[2009年北京市职工年平均工资为48444元 再谈可转债 黄金ETF也将是未来ETF计划配置的一份子 倒计时：921天 你敢在舒服点的地方睡吗 我们一起追火车 近期市场观察+整体趋势和整体价值 第一期建仓完毕 巴菲特降至半仓的启示 近期最有意思：国债收益飙升 无法下手 嗯。。 2011.09.24 资本市场真相记录：股民号召股民清仓销户，永远退出股市 金戈铁马，号角吹响了 注册制 男性健康日 不投资，你的存款在银行会变成渣 etf计划的2011 新庄股 从容 今日研究&amp;强烈关注 转债的卖出时机 从另一面说说QDII 一个决定 本月两份+送给新加入的朋友几句话。 冲向20 本月依然：0 2011.1.9 投资周记+谈谈信李驰 中证消费10年来大致pe 人生 I 十个人的“微表情”：私募大江湖的小小缩影 今天有场大战役/没搞满！ 其实最重要的是：常识 我的偶像给比尔盖茨夫妇的信 我为鑫利数日子(2012-8-30 : 归一，结束)——0.98金利清仓 发两张图，欢迎大家讨论。 201506：本月卖出3份，买入2份 基金2010年上半年业绩统计报告 鲁泰半年报 拭目以待 再见，2011 即日起，ETF计划加入四只新的品种 2011前三季度将要过去，总结etf计划过去21个月的表现 2007启明基金大的投资策略 让我舒服的持仓：2012-05-04 乌云盖顶 BDI再回前期高点、PMI重上50 NEW PP 如果我们的etf计划是公募，将会很风光 每天a类精彩大戏不断，没精力一个个说了 持仓变化 关于估值的一点想法 年终投资回顾一：定投计划开门红，战胜大盘27% 风光的背后：真相能否让你领悟？ 建行翻番了 吃一堑要长一智 送给新朋友的几句话 日本09年人均月薪创历史最大降幅 预告：虽然最近越来越忙，但有几个题总想写一写 下一个目标：工行转债 又捐了 长跑 照常理，这应该是一篇耻辱柱——2011投资策略大探市 30家券商巨头纷争牛熊 你永远猜不透市场 2011年第4-7本好书——《投资者的未来》及其它 浅谈资产再平衡 网格转债 资产下跌之后的心态 房地产股能不能买？ etf计划有意思的数据 PE|PB跟踪更新帖(2012.12.03：pb\pe再创新低：pb 1.94！) 割掉毒瘤 让利润奔跑 各种量化投资计划电梯 谢谢你，忘了3000点吧。 写给“zhtgyl”——商讨ETF计划的一些问题 1st day CPI 嗯。 新题目：去超市败家的同时买超市 推迟满足感 1/3了 机器人 大道相通 我爱基金 遭受挫折，决定学坏 AH股溢价指数首次破百 A股迈入“折价时代” 2011年第26周好书——赛斯卡拉曼：《安全边际》 超级无敌大熊市？不识庐山真面目，只缘身在此山中 现金为王 中行转债 再见2012，我会怀念你 投资到底有多难？ 2013.02 本月买卖份数：0+两个记录诞生的背后 基金三季度新增前20大重仓股(按市值排序) 成功的投资到底靠什么？ 本月买入一份（11.08.01） 小统计 社保基金个人账户年均收益率18.9%——未来将异常惨烈 到底什么是金融投资 饺子 公司债暴跌，是否有机会？ 可爱的公募基金——基金踏空此轮行情 后市面临调仓压力 似乎只有中国资本市场在承受金融危机后遗症 黄金、白银T+D 医药 拨开股市的迷雾——到底是什么决定了涨跌 最近盯的机会 阳光私募半年成绩单出炉 明星陨落新军突起 持仓A类一览 开始关注A类 2011年第28周好书——《巴菲特致股东的信1957-2010》 加博友/10.04修改添加方法 网格第四轮清仓完毕 顺藤摸瓜找出的好文章：择时交易的小概率困境 再说资产配置 2009年10大熊股 10看好 你比82.45%的基金经理强 什么是真正的价值投资 …… 封闭式基金已经进入极度可投资区域 周末，我家窗外… JOEY之死 定投收益的预期收益率应该是多少？ “墨菲定律”： 再顺便上几张照片吧，两周前拍的。 短线将发生一些有意思的事情 年底回来看成败：四成专家认为明年上证指数将超过3500点 清仓A类 这轮反弹以来，别人都赚了多少？ 整体估值一览，记录疯狂年代 中国的股民比我想象的还可怕：今年居然有61%的人亏损 此时此刻，我们的A股是不是“历史估值最底部”？ 买车股好过买车 11.10.19 资本市场真相记录:银行持续两年pe不到10倍，股市真的是无效的？ 复杂系统中，会发生很多不可预计的事情 ETF计划所有品种全面翻红 4月输了 5月新起点 投资长赢的真谛 BDI、上证指数和中海发展 写字ing 同辉100A 从建行贷款然后买建行股票 ETF计划中的中小ETF、500ETF创2年新高 所谓人生好时节… 再说杠杆 估值、趋势以及未来策略 2010年度总结（投资篇） 乱弹历史——四大发明之一：活字印刷术 赔死你们这些抢反弹的！ 挺有意思的一个新闻 暴风雨的前夜 卖出一份 万事皆可解决 半仓了 关注H股A TVB常见台词 本周好书推荐：《金融的逻辑》 做了张图，希望大家热烈讨论 调整中的加仓位置 简单惊人的“M1定买卖”投资法 换了主题，囧 拉登与中国的股市、楼市 爱之韵 降息？I don’t care da shi say 记录一件事情，发表一个感慨 开始大幅超越指数+2份 很多东西不在这里写了。朋友可以去雪球关注 只涨了一天,pe就没法看了 百年孤寂的投资女神 简单执着，见证投资传奇 鑫瑞现价1.345，溢价过多。出货 下跌不远了 华宝油气两轮网格完毕 猎人 ETF计划 Q &amp; A (13.10.21更新Q4) 3rd day 一切按照剧本行动 PB和scofiled的粉丝们看了这个广告 新年第一个月：卖出一份 消费etf已入仓位配置 股票？真没啥可看的了 中国股市也属于地球 三论金利收益 刚看了看etf这两周的收益，又看了看好买的基金排名，我彻底无语了 请注意债券收益率 2010.12.04 市场观察周记 大概说说etf分红 今天，我来谈谈预期收益率 google,我服了你了 ETF+金利的投资逻辑 关于etf计划收益率的计算，最后一次阐述 冤枉招行了 穷人与富人的不同思维 M 本人现阶段资产配置表 你炒股吗 我们都会在资本市场取得我们应得的收益 看了上一贴的评论，感觉是万万没想到 给苹果——金利为何一路下行 十券商策略报告准确率仅47% 申万最准海通垫底 好吧，谈谈个股 2011，困难的一年 顺大势而为 启明基金一期顺利结束，二期开始运作 本月卖出3份 指数还在半山腰，四成个股已新高 也许这才是老美不停新高，老A牛短熊长的根本原因 关于量化交易的几个问题，欢迎大家积极讨论 预祝所有博友新年快乐！ 用行动鉴证价值 华宝添益2天年化收益率超过20% 学习的力量 价值投资——今日再涨停 2张图让你看懂中国投资者，争取每周更新 没有机会的日子只能等待 人的一生，就像乘坐一辆公交车 读书心得【贰】：自我价值与别人的赞许 同瑞开始涨 大风起兮猪飞扬 今年的大机会在哪里 1.39卖掉剩下的20%，清仓鑫瑞 鸭子 只渡有缘人 不买汽车买汽车股第一期结果 有没有博友愿意为大家做道题？ 关于针对标普500与恒生的一些投资想法 财神助威 今天开始 现阶段持仓比例 门票策略盘（更新完毕） 大家误会了 继续兴奋 深机转债也不错 握紧你的筹码 南山转债是股还是债 and 稳进和金利又开始犯2 投资大师的长寿 动态再平衡组合 2012那一天… 第二只公布股 创A已清仓。 他们再次预测：下半年上证指数将达3500点 医药、消费即将上市 2nd day 越看书 越纠结 关注日元 安全边际 不详的预感 920，+1关注 别人狂热你冷静，别人恐惧你继续冷静 从历史看未来 不玩了。关注A股的同学近期不必来这里了 不出所料 上周交易户数\持仓户数简评 转债最关键的几个价位 有些人可以帮你评价估值 再帖一次 回答“百志惟熙”朋友关于etf的几个问题 同学们，来来来，都冒个泡 我们财富的过去、现在和未来（历史篇） 我会买的股票 查阅美国人寿公司市值，翻出疯狂的年代 大跌眼镜 门票目标，2015第一季全出炉 改了 给某位网友： 我啥都不想说了。。 套利华宝添益 混沌的估值结构 选品种——底部到来之前的风险与收益 网易帐户密码被盗 给“yuup”，出租小房子好还是金利好 网格操作记录——2014.11.28 3.22 卖出 彻底清仓 关于同辉100A未来三年收益率 投资，就是一部挑战人性的修炼史 我的股票池 全部盈利 本月卖出一份 先不写了 简单生活 100etf持仓明细：这些好公司可以一次全都持有，别无所求了 一个回顾 价值股。净资产收益率每年&gt;10 余额宝完成了我的一个梦想 好日子总是消失的很快 2015 网格计划一：恒生 / 15.01.13 首笔获利完成 套利交易 一篇新闻+几个数据，请大家自己思考投资的奥义 全球银行市净率排行4中资行挺进前五 无股可买的巴菲特 去年赚了73亿美元 今年看起来会延续盈利 很少转载文章，今天转载一篇：人民财评：股市散户疯狂原因何在？ 基金大佬竞相上马行业系列ETF 7家大公司推出 停止黑嘴 张老板和弘毅已经解套 大戏会上演吗 金利历史新高，笑看风云 ETF计划再次开始盈利，战胜同期97%股票基金 低风险高收益——现阶段投资金利、稳进、500a的可行性分析 又一次买在最低 非常简单的第一次行业pe统计 回来了+中国经济硬着陆 在这个浮躁的时候，推荐大家看两本书 … 整个中国股市被一部动画片占领了 五福临门 一则小声明 如何积阴德之几件小事 企业盈利确实在下降 一字头后的市场数据——决战的号角即将吹响 新的计划 上一期的定投计划回报情况，留作纪念 跑赢大盘的复利意义 7% 使你的后悔最小化 不是正式的心得 只有两种可能 无人纪念 平心而论，炒股还有意义吗？ 第三次回顾 你我如果没有梦想，那么跟一条咸鱼有什么区别？ 以投资实体经济的理念来投资股票 博汇转债 中证全指七行业历史pe 新钢转债 轻松踏上理财之路 本月买入一份 赤子之心，于我心有戚戚焉 2010.12.12 市场观察周记 不得不说，欧债危机开始升级了 行情总是在绝望中产生，在犹豫中发展 为什么整体市盈率很重要 开始真正的长期投资 跑赢大盘 记录历史的一刻。 再次关注可转债 惜福、习牢、持戒、自尊 本月不买不卖 截止11:30，pe到了33.5 88888 该写点东西了 攻守相宜可转债 卖掉一半，笑纳利润 看电视，无语 关于“生”和“死” 第一笔建仓完毕 欢迎添加公众号 现阶段的套保思路——给偏保守的朋友 人生 II 关于同辉100a的买入价格 突然明白的一件事 价值投资 截至今天，今年你再次战胜了80%多的基金经理 从分红角度计算中海发展的投资价值 可怕的pe 卖出部分华安石油 机会慢慢出来了 友情提示：有转债的同学赶紧清理干净 BDI重新跌至916点 福缘 下周会大跌 ETF计划的两个小数据 必须说点什么了 欢迎大家讨论合适抄底的标的物 采纳博友意见，给各指数pe值 什么是幸福 提醒 婚姻和股市 飞跃疯人院 行业PE\PB统计计划正式启动 宏观经济、A股和上证 散户怎能不死？这样操作你不死谁死？？？？ 你是来炒股的，还是来赚钱的？ 中国股市的估值到底是多少？ 五一游记 狗的礼赞 2010年05月24日 A类大戏即将上演 好文共赏——人生不同阶段的投资规划 即将进入死亡之顶 五年最牛公司实盘试验 恩 情绪变化导致机会不断出现 年底了，这几天打算写个长点的东西。 最新结构 同学们，你们账户里真的清干净了？ 投资近六年来给我赚钱和赔钱最多的股票 锐进低折后 机会，跌出来了 这应该算是开了吧。 2011年11月——本月买入2份 我们的tenbagger 今日DCSX指数 帮一个朋友算的，顺便贴出来 12月定投：卖出一份 很黄，很暴力。。。 六一儿童节 如何化解2008年犯太岁(马、鼠、兔、羊)必看 持仓帐户增加了 180的逆袭 180etf分红 。 big money 史无前例的金融时代 还有没有A类亏损的朋友了？ 试验新的量化模型 还能拿多久？ oops… 巴菲特的最新持股——送给认为巴菲特就是买入不动的人 价值投资区域 油气网格开始 投资 研究贴：各大指数的十大权重股 2011.4 等待8个月后，终于——买入一份 不论公募、私募还是散户、机构，希望主动长期超越市场都是妄想 2008 周五收盘前操作的理由 恭祝大家龙年吉祥！ 利率应该怎么用 江晖：践行绝对收益之率之路！ 一封信 虽不为僧，大义相通 买卖的节奏 比较开心 晚安，2010 - 修罗的2010纪念册 两个数据，一个结论 截止今日，所有参加etf计划的朋友都盈利了 518880 再次总结ETF计划总收益、分年度收益以及与各类基金对比 他们增持了，你呢？ 本月两份 油气每日净值预测 2011年第30周好书——《财报就像一本故事书》 日元暴涨3% 2000点说仓位 趋势账户，招行依然不给力 最需要得到的 15年前的5月21日 2011.10.16 资本市场真相记录：送气工3000元变600万 真相并不重要 上市公司企业利润确实在下降，但降幅非常有限 无耻的上交所 且行且珍惜 etf的特大喜讯，终于来了 中国股市问题之一是散户太多 应博友要求贴出pe 做一个自由支配自己与其时间的贵族 2011.05 买入一份 2011.1.20投资周记 投资 性格最重要 买鑫利的脑残再次出现了 写在这个伟大的日子 寻找明珠系列 1：鲁泰 随便说说股票 关于大盘 转载难得一见的好文章——经济的“中国模式”走向终结 判断题：我们现在处在哪个阶段？ 关于中行转债 定投是否真的如此美妙 加息 2008哪些人犯太岁以及化解太岁的方法 柳暗花明 倒数 快与慢 2011.02。 本月不买不卖+我们的投资未来 今天在开心网上看到一个题，挺有意思。。 停止谈论个股 为别摸我买了第一年的保险 买基金的人，胆子最大了 趋势与价值 上一个十年的大牛股是谁，下一个十年的大牛股在哪里 什么时候卖股票 随手存数据——壹 深市成交额十年来首超沪市 资金从大盘股中撤离 不成熟的想法，从M1数据来考虑 怎能不得瑟？ 跌了，看着就舒服多了。下个月可以继续买了 持仓帐户连续新高后，2513，开始有人割肉了 两个小寓言 权作留念 上周交易户数、持仓户数简评 毒贩住在父母家里 港股的诱惑 ETF计划的好消息 记录现在，受益未来 联合国说 继续记录成绩 慢慢的开始激动起来 怎么战胜通胀 支持HH 珠三角缺工超200万人：部分生产线已处停工状态 版权归ETF拯救世界所有，不得用于盈利性目的]]></content>
      <categories>
        <category>E大博文</category>
      </categories>
      <tags>
        <tag>经济</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[书单备忘录]]></title>
    <url>%2F2018%2F11%2F24%2F%E4%B9%A6%E5%8D%95%E5%A4%87%E5%BF%98%E5%BD%95%2F</url>
    <content type="text"><![CDATA[已读清单： 缠中说禅天才在左，疯子在右：精神病人采访实录浪潮之巅：各大科技公司历史简述大癫狂：群体性狂热与泡沫经济，人性从未改变查理·芒格的智慧：投资的格栅理论（原书第2版）查理·芒格的原则彼得·林奇的成功投资（珍藏版） (华章经典·金融投资)投资者的未来 行为投资学手册：投资者如何避免成为自己最大的敌人秦朔访问以交易为生(珍藏版) (华章经典•金融投资)股票大作手回忆录(修订版)通向财务自由之路(原书第2版•珍藏版) ：构建完整交易系统必读股票大作手操盘术:融合时间和价格的利弗莫尔准则穷查理宝典：查理·芒格的智慧箴言录笑傲股市(原书第4版) (华章经典•金融投资)纳什均衡与博弈论股市真规则自律的交易者思考，快与慢习惯的力量（精编图文版）反脆弱:从不确定性中获益金融心理学低风险投资之路手把手教你读财报:财报是用来排除企业的邓小平时代滚雪球腾讯传投资最重要的事投资最不重要的事干法穿越迷雾：巴菲特投资与经营思想之我见颠覆者：周鸿祎自传华章经典·金融投资 投资心理学（原书第5版）怎样选择成长股（珍藏版）投资的护城河 晨星公司解密巴菲特股市投资法则乌合之众：群体时代的大众心理（精装插图版）-“慢读”系列学会估值，轻松投资 [美] 阿斯沃斯·达摩达兰 中信出版社图书跳着踢踏舞去上班指数基金投资指南止损：如何克服贪婪和恐惧（经典好书，简析交易心理）黑天鹅 如何应对不可预知的未来（升级版）量价分析：量价分析创始人威科夫的盘口解读方法股市天才：发现股市利润的秘密隐藏之地（无聊的书）股票短线交易的24堂精品课：超越技术分析的投机之道（第二版 套装上下册）百箭穿杨超额收益：价值投资在中国的最佳实践投资第一课低风险投资之路（第2版）江恩测市法则（第2版）鲁兆股市预测与实战操作系统人格心理学（第七版）（万千心理） 每天学点管理学全集 正在阅读：选择的悖论:用心理学解读人的经济行为原则人类简史逃不开的经济周期：历史，理论与投资现实时运变迁：世界货币、美国地位与人民币的未来 未读清单：重来清醒思考的艺术简单逻辑学算法数据库索引设计与优化高性能MySQL（第3版）战争风云：二战回忆录现代经济学大典：产业经济学分册（太枯燥了….）下一场全球金融危机的到来 明斯基与金融不稳定（太枯燥了….）货币的祸害大国政治的悲剧走向繁荣的战略选择]]></content>
      <categories>
        <category>书单</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[markdown语法说明]]></title>
    <url>%2F2018%2F11%2F21%2Fmarkdown%E8%AF%AD%E6%B3%95%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[你能看到这篇文章，说明你基本已经知道markdown是什么了，所以我们直奔主题。 markdown的基本语法非常简单，分为： 标题，段落，区块引用，代码区块，强调，列表，分割线等。 No1.标题用 = 和 - 标记一级和二级标题，效果如下一级标题（在这串文字下方加=====）二级标题（在这串文字下方加—–） No2.使用#可以表示1-6级标题，一个#表示一级标题，以此类推，注意#和文字之间有空格，效果如下一级标题二级标题三级标题四级标题五级标题六级标题No3.区块引用，在段落的每行或者只在第一行使用符号&gt;，嵌套引用就用多个&gt;，如:&gt;&gt;，效果如下 这里是区块引用 这里是嵌套引用 No4.代码区块（TODO-LIST）No5.强调，在强调的两侧加*,**表示斜体，****表示粗体斜体粗体 No6.列表，使用 * + -标记无序列表，有序列表的标记方式是将上述符号换成数字，并辅以. 第一项 第一项 第一项 第一项 第二项 No7.分隔线常用的是三个或以上*、-、_,三个效果相同 No8.链接有两种形式，行内式和参考式，链接需要是完整的行内式：[文字](链接) 参考式： [文字1][1] [文字2][2] [1]:这里是链接，页面不会直接显示 [2]:这里是链接，页面不会直接显示 效果如下： google 这里只有行内式的，因为参考式的我调不出来….. No9.图片链接，和上述添加链接相似，需要在链接的前方加一个!格式:![中括号必须有,内容好像写什么都没关系](图片的链接 “图片下方显示的字”) No10.标记符号`，在反引号中间添加需要标记的内容我是反引号中间的内容 Tips: 在文章任意位置加 &lt;!--more--> ,只展示到该位置，保持主页整体简洁返回最上方]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 配置next主题]]></title>
    <url>%2F2018%2F11%2F20%2Fhexo-%E4%BD%BF%E7%94%A8next%E4%B8%BB%E9%A2%98%2F</url>
    <content type="text"><![CDATA[配置next主题 1、进入blog目录 2、首先通过git下载next主题 1git clone https://github.com/iissnan/hexo-theme-next themes/next 3、修改_config.yml文件 E:\test\blog 1theme: landscape 4、切换主题风格，在E:\test\blog\themes\next目录下找到_config.yml文件，修改scheme的value 1scheme: Mist 5、保存，启动hexo server，访问4000端口，测试博客是否正常访问 Tips: 启用阅读量统计,修改next配置文件_config.yml中的 leancloud_visitors字段，其中app_id和app_key需要去 https://leancloud.cn 注册配置 1234leancloud_visitors: enable: true app_id: # your leancloud application appid app_key: # your leancloud application appkey 启用评论系统，在valine配置申请号的id和key 1234567891011121314valine: enable: true appid: # your leancloud application appid appkey: # your leancloud application appkey notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: ... # comment box placeholder avatar: mm # gravatar style guest_info: nick # custom comment header pageSize: 10 # pagination size meta: nick #目前我配置好后，评论数统计一直是零，不知是哪里有问题，有踩过坑的盆友请联系我 #更新:原来我把facebook_comments_plugin配置为true了，导致冲突，把这个关闭就正常了]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Blog]]></title>
    <url>%2F2018%2F11%2F20%2Fhello-blog%2F</url>
    <content type="text"><![CDATA[Now is the time for all good men to come to the aid fo their country. 发布文章的步骤： 1、hexo new 创建文章 2、Markdown语法编辑文章 3、部署（所有执行命令都是在blog目录下） Tips:hexo clean #清除缓存 网页正常情况下可以忽略此条命令hexo generate #生成hexo server #启动服务预览，非必要，可本地浏览网页hexo deploy #部署发布]]></content>
  </entry>
</search>
