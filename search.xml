<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ARTS合集链接]]></title>
    <url>%2F2019%2F01%2F17%2FARTS%E5%90%88%E9%9B%86%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[2019年第三周 Algorithm:找出最长的共同前缀shell的四道算法Review:工作的意义Share:Notes to Myself on Software Engineering]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Share之Notes to Myself on Software Engineering]]></title>
    <url>%2F2019%2F01%2F17%2FShare%E4%B9%8BNotes%20to%20Myself%20on%20Software%20Engineering%2F</url>
    <content type="text"><![CDATA[原文在这里 文章主要讲了三部分内容，分别关于编码、API、和职业生涯的一些建议。 有几点读来比较有感触，如：1、代码是给人看的，不是给机器看的，好的代码不只是运行完美，更重要的是易于阅读和维护2、pull request 应该是解决用户或者团队的一些问题3、业务需求提过来，要深入了解思考，要和业务有充分的沟通，确认是否是必要需求。同时要站在整个系统的构建层面考虑需求，不只是单个功能 4、API要简单易用，容错率要高，不能依赖用户解决问题 5、做一些大家需要的东西，而不是自己想做的东西 很多内容都很有意思，适合自己阅读，也适合分享给自己的团队学习。]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tips之维护中的代码风格问题]]></title>
    <url>%2F2019%2F01%2F15%2FTips%E4%B9%8B%E7%BB%B4%E6%8A%A4%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[代码维护是开发工作中无法回避的痛，维护自己写的代码还好，无论风格好坏，起码顺眼，修改以后也依然看得出是同一个人写的。 哦，对了，还有一种情况是，看到自己以前写的代码，会默默的吐槽“卧槽，我怎么会写这么傻的代码！”，然后再默默的修改成符合我们当下状态的代码。 但是，如果你维护的别人代码呢，如果他的代码风格比较规范还行，跟着规范继续改就好了，风格一致不会给人造成突兀的感觉。 如果你要维护的代码风格和我们自己的风格格格不入，而且你的前同事不符合规范呢。我们是按照自己的风格维护呢？还是延续老代码傻傻的写法呢。 目前，我的做法是延续他的做法，哪怕他的写法很傻，这样风格一致，“规范”一致，不会造成阅读上的障碍，虽然你开发的时候会比较难受，一边吐槽一边写。 如果实在无法忍受，那就只好重构一遍代码，让整个代码的风格保持一致。]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode之shell]]></title>
    <url>%2F2019%2F01%2F15%2Fleetcode%E4%B9%8Bshell%2F</url>
    <content type="text"><![CDATA[leetcode上关于shell的题目一共才4道，估计是大家用的比较少吧。莫名感到为自己感到凄凉，最擅长的玩意儿没什么用。 一共才4道题目，索性就放在一篇文章写吧。题目一： Given a text file file.txt that contains list of phone numbers (one per line), write a one liner bash script to print all valid phone numbers. You may assume that a valid phone number must appear in one of the following two formats: (xxx) xxx-xxxx or xxx-xxx-xxxx. (x means a digit) You may also assume each line in the text file must not contain leading or trailing white spaces. Example: Assume that file.txt has the following content: 987-123-4567123 456 7890(123) 456-7890Your script should output the following valid phone numbers: 987-123-4567(123) 456-7890 考察正则，匹配指定格式的字符串，考虑周全一点没什么难度。先上代码，再聊思路。1234cat file.txt|sed 's/^ *//g'|awk '&#123; if ($0 ~/^[0-9]&#123;3&#125;-[0-9]&#123;3&#125;-[0-9]&#123;4&#125;$/||$0~/^\([0-9]&#123;3&#125;\) [0-9]&#123;3&#125;-[0-9]&#123;4&#125;$/ ) print $0 &#125;' 题目二：Given a text file file.txt, print just the 10th line of the file. Example: Assume that file.txt has the following content: Line 1Line 2Line 3Line 4Line 5Line 6Line 7Line 8Line 9Line 10Your script should output the tenth line, which is: Line 10Note: If the file contains less than 10 lines, what should you output? There’s at least three different solutions. Try to explore all possibilities. 输出第10行。1awk 'NR==10' file.txt 对awk内置变量熟悉的，这道题没什么难度。 下面两道题稍微难一点。题目三：Write a bash script to calculate the frequency of each word in a text file words.txt. For simplicity sake, you may assume: words.txt contains only lowercase characters and space ‘ ‘ characters.Each word must consist of lowercase characters only.Words are separated by one or more whitespace characters.Example: Assume that words.txt has the following content: the day is sunny the thethe sunny is isYour script should output the following, sorted by descending frequency: the 4is 3sunny 2day 1Note: Don’t worry about handling ties, it is guaranteed that each word’s frequency count is unique.Could you write it in one-line using Unix pipes? 全文统计单词出现的频次。利用awk的数组就可以实现，awk的数组下标可以是字符串。 1awk '&#123;gsub("\\\\n"," ");printf("%s ",$0)&#125;' words.txt |awk '&#123;for ( i=1;i &lt;= NF;i++ ) a[$i]++&#125;END &#123;for (i in a) print i,a[i]&#125;'|sort -k2 -r -n 先把全文处理成一行，然后单词作为下标统计次数就可以了。测试中居然有显示的\n，所以前面加了处理。最后按照数字排序就可以了。 最后一道题，比较麻烦：Given a text file file.txt, transpose its content. You may assume that each row has the same number of columns and each field is separated by the ‘ ‘ character. Example: If file.txt has the following content: name agealice 21ryan 30Output the following: name alice ryanage 21 30 行转列输出。 12345678910awk '&#123; for(i=1;i&lt;=NF;i++) a[NR][i]=$i&#125;END&#123; for (i=1;i&lt;=NF;i++) &#123; for(j=1;j&lt;=NR;j++) printf("%s ",a[j][i]) print "\n" &#125;&#125;' file.txt|sed '/^$/d'|sed 's/ $//g' 我用了二维数组，利用NF和NR记录和输出，最后把输出的空行以及结尾的空格显示处理掉。 shell对于写应用或者系统也许用处不大，但是对日常工作还是挺有帮助的。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode之Longest Common Prefix]]></title>
    <url>%2F2019%2F01%2F15%2Fleetcode%E4%B9%8BLongest%20Common%20Prefix%2F</url>
    <content type="text"><![CDATA[问题描述： Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string “”. Example 1: Input: [“flower”,”flow”,”flight”]Output: “fl”Example 2: Input: [“dog”,”racecar”,”car”]Output: “”Explanation: There is no common prefix among the input strings.Note: All given inputs are in lowercase letters a-z 大概意思就是在数组元素中找到最长的共同前缀先上代码，再聊思路。1234567891011121314151617181920212223242526272829303132333435func min(x,y int) int &#123; if x &gt; y &#123; return y &#125; return x&#125;func startWithKey( s string,key string) bool &#123; return key == s[0:len(key)] &#125;func longestCommonPrefix(strs []string) string &#123; var m int var mp = make(map[int] string) if len(strs) &gt; 0 &#123; m = len(strs[0]) mp[len(strs[0])]=strs[0] &#125;else &#123; return "" &#125; for i:=1;i &lt; len(strs); i++ &#123; m = min(len(strs[i]),m) mp[len(strs[i])]=strs[i] &#125; cn := m for i:=0;i&lt;len(strs);i++ &#123; if cn&gt;0 &amp;&amp; !startWithKey(strs[i],mp[m][0:cn]) &#123; cn-- i=-1 //确保i从0开始 &#125; &#125; return mp[m][0:cn]&#125; 先找出元素中最短的字符串同时构造一个map mp 存放数组元素和其对应的长度。然后循环查找各元素是否以最短字符串开头，如果不是，则最短字符串截前N-1位，然后从头再查一遍数组。最好的情况耗时：len(strs)+min(cn,len(strs)) 大家没有共同的前缀或共同前缀就是最短的那个字符串最坏的情况耗时：len(strs)+（N-1)*cn 前N-1个元素的0到cn-1位都相同，最后一个数组元素和大家都不同]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Review之为什么工作]]></title>
    <url>%2F2019%2F01%2F15%2FReview%E4%B9%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B7%A5%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[原文链接在这里，不知道需不需要翻墙。 文章题目是：How A Hacker Helped The Coast Guard Rescue Victims Of Hurricane Harvey，在我的google邮箱中收到了这篇文章的推送，我也是被他的题目吸引进去的，本以为是讲一些酷酷的hacker技术，然而…并不是。 文章的被采访者是一名普通的map开发工程师，像你我一样，普通的程序猿。嗯…也许不一样，他的技术厉害很多。 他干了些什么事呢？其实也没什么，在map上增加一些标识，标记哪里有需要救援的人，哪里可以求助等等，主要就是围绕救援这个主题开发了好多功能。 你看，我们也可以实现的吧。 但是，这个事情让主人公找到了工作的意义，也许这么描述不是很准确。虽然这个工作占用了他很多的时间，但是他还是很愿意做这个事情，因为能帮助到很多人。 触到我的点是，我们常常觉得自己的工作没什么意思，自己学到的那点儿技能也什么都做不了。 其实，这里有两个点，也许我们的技能真的什么都做不了，因为才疏学浅啊，需要继续学些。 另外一个是善于发现，我们大多都是埋头苦干型的，其实我们也许需要抬头看看，发现一些痛点，做一些解决或者服务社会的东西，也许产品很小，小到无法称之为产品，但是那些被帮助的人们，会发自内心的感谢大家。]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>Review</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode之Roman to Integer]]></title>
    <url>%2F2019%2F01%2F11%2Fleetcode%E4%B9%8BRoman%20to%20Integer%2F</url>
    <content type="text"><![CDATA[问题描述： Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol ValueI 1V 5X 10L 50C 100D 500M 1000For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9.X can be placed before L (50) and C (100) to make 40 and 90.C can be placed before D (500) and M (1000) to make 400 and 900.Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.Example 1: Input: “III”Output: 3Example 2: Input: “IV”Output: 4Example 3: Input: “IX”Output: 9Example 4: Input: “LVIII”Output: 58Explanation: L = 50, V= 5, III = 3.Example 5: Input: “MCMXCIV”Output: 1994Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. 将罗马数字映射为中文数字。先上代码，再捋思路。 1234567891011121314151617181920212223242526272829303132func romanToInt(s string) int &#123; roman := map[string] int &#123; "I":1, "V":5, "X":10, "L":50, "C":100, "D":500, "M":1000, "IV":4, "IX":9, "XL":40, "XC":90, "CD":400, "CM":900, &#125; var max,begin,sum int for i :=1 ; i &lt;= len(s) ;&#123; if k,ok :=roman[s[begin:i]];ok &amp;&amp; k &gt; max &#123; max = roman[string(s[begin:i])] i++ &#125; else &#123; begin=i-1 sum += max max =0 &#125; &#125; return sum+max&#125; 将所有罗马字母的基础组合放到map中，其他所有数字均由这些加和而来。然后依次检查给定字符串，如果在map中就记录下来，然后i向前走一步，begin不动，此时被检查字符成为两个字节，map中存在且大于之前的数字，就继续下去，如果不存在，或者不大于之前的数字，begin向前走到i-1的位置，而i不动，被检查字符成为第二组。依次循环直到最后一组。 eg：参数为 MCMXCIV （索引下标从0开始） begin=0 i=1 M 在map中begin=0 i=2 MC 不在map中begin=1 i=2 C 在map中begin=1 i=3 CM 在map中begin=1 i=4 CMX 不在map中begin=3 i=4 X 在map中begin=3 i=5 XC 在map中begin=3 i=6 XCI 不在map中being=5 i=6 I 在map中begin=5 i=7 IV 在map中i&gt;len(s) 结束循环 Tips： 在go中 s[0:1] 表示s的第一个字符，而s[1:1]是空，所以上述代码中，i是字符串的长度且从1开始，begin从0开始，最大为len-1。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode之Reverse Integer]]></title>
    <url>%2F2019%2F01%2F10%2Fleetcode%E4%B9%8BReverse%20Integer%2F</url>
    <content type="text"><![CDATA[问题描述： Given a 32-bit signed integer, reverse digits of an integer. Example 1: Input: 123Output: 321Example 2: Input: -123Output: -321Example 3: Input: 120Output: 21Note:Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. 将给定数字反转，注意正负号，如果超出int32则返回0.先上代码，再捋思路。123456789101112131415161718192021222324252627func mod (x int) int &#123; return x%10&#125;func sub ( x int) int &#123; var array []int var sum int for i:=0;;i++&#123; if int(math.Abs(float64(x))) &lt;= 9 &#123; array=append(array,x) break &#125;else &#123; array=append(array,mod(x)) &#125; x=x/10 &#125; l:=len(array) for i:=0;i&lt;len(array);i++ &#123; sum += array[i]*int(math.Pow10(l-1)) l-- &#125; if sum &gt;int(math.Pow(2,31)-1) || sum &lt; -int(math.Pow(2,31)) &#123; sum = 0 &#125; return sum&#125; 大体思路是，循环取余，直到x成为个位数，取余完成后，array存的数组就是x从低位到高位的数字，然后依次*10^n加和就得到反转后的数字了，n是array的长度-1，array的长度就是x的数量级。更新代码：1234567891011121314151617func sub2(x int ) int &#123; if x &gt;=0 &amp;&amp; x &lt;=9 &#123; return x &#125; rev := 0 for x != 0 &#123; rev = rev*10 + x%10 x=x/10 &#125; if rev &gt;int(math.Pow(2,31)-1) || rev &lt; -int(math.Pow(2,31)) &#123; rev = 0 &#125; return rev&#125; 代码运行性能相同。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode之twosum]]></title>
    <url>%2F2019%2F01%2F09%2Fleetcode%E4%B9%8Btwosum%2F</url>
    <content type="text"><![CDATA[问题描述： Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 大概意思就是找到目标数字是由那两个数组元素求和得到的，同一个元素不能用两次，也就是说返回值不能是 0,0 或者 1,1 这样的。先上代码，再聊思路。12345678910111213141516171819202122func twoSum(nums []int, target int) []int &#123; i :=0 j :=0 l:=len(nums)loopfor: for i =0;i&lt;l; i++ &#123; firstone := target-nums[i] for j=i+1;j&lt;l;j++ &#123; if firstone == nums[j] &#123; break loopfor &#125; &#125; &#125; if i &gt;=l || j &gt;= l &#123; i = -1 j = -1 &#125; ret := []int&#123;i,j&#125; return ret &#125; 题目好像没讲如果找不到这样的组合返回什么，但是程序中还是要处理一下，就用通用的-1代表没找到吧。 我的思路是这样的，给定目标数字，且由两个不同的数组元素组成，所以用目标数字依次减数组元素，所得结果一定是数组元素，且其下标一定大于被减元素下标。如果循环完，还没找到，那就是没有这样的组合。 需要注意的是 j=i+1 这里，因为题目规定同一元素只能用一次，所以寻找结果要从被减下标的后一位元素开始，而不能从其本身开始。 思路二来了： 可以利用map的特性，将循环次数降低，时间复杂度为线性；12345678910111213141516func twoSum(nums []int, target int) []int &#123; var m=make(map[int] int) var diff []int for i:=0; i&lt;len(nums); i++ &#123; m[nums[i]]=i diff=append(diff,target-nums[i]) &#125; for i:=0;i&lt;len(diff);i++ &#123; if _,ok :=m[diff[i]];ok &amp;&amp; i != m[diff[i]]&#123; return []int&#123;i,m[diff[i]]&#125; &#125; &#125; return []int&#123;-1,-1&#125;&#125; 这个思路更简单了，原数组放在map中，差值放在数组中（差值放在map中会导致返回的索引下标随机报错）；然后循环查找diff数组中的元素是否在map中；diff[i] 这里的i是与目标数组做差值的索引下标，而diff[i]是差值，m[diff[i]]就是另外一个数组的下标了。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARTS]]></title>
    <url>%2F2019%2F01%2F09%2FARTS%2F</url>
    <content type="text"><![CDATA[转自左耳听风Algorithm。主要是为了编程训练和学习。每周至少做一个 leetcode 的算法题（先从Easy开始，然后再Medium，最后才Hard）。进行编程训练，如果不训练你看再多的算法书，你依然不会做算法题，看完书后，你需要训练。关于做Leetcode的的优势，你可以看一下我在coolshell上的文章 Leetcode 编程训练 - 酷 壳 - CoolShell。 Review：主要是为了学习英文，如果你的英文不行，你基本上无缘技术高手。所以，需要你阅读并点评至少一篇英文技术文章，我个人最喜欢去的地方是 http://Medium.com 以及各个公司的技术blog，如Netflix的。 Tip：主要是为了总结和归纳你在是常工作中所遇到的知识点。学习至少一个技术技巧。你在工作中遇到的问题，踩过的坑，学习的点滴知识。 Share：主要是为了建立你的影响力，能够输出价值观。分享一篇有观点和思考的技术文章。 转载做备忘录，在coding的道路上坚持下去。]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法漫步之纸牌排序]]></title>
    <url>%2F2019%2F01%2F08%2F%E7%AE%97%E6%B3%95%E6%BC%AB%E6%AD%A5%E4%B9%8B%E7%BA%B8%E7%89%8C%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[题目为：如何将一副扑克按花色排序，花色顺序是黑桃、红桃、梅花和方片。限制条件是所有牌都是背面朝上排成一列，而你一次只能翻看两张牌或者交换两张牌（保持背面朝上）。 思路一： 只看花色不看数字，数组的值只有四种，假设为 0 1 2 3 分别代表四种花色，然后统计每种花色各多少张，最后在各自的位置上放上对应数量的花色。12345678910111213141516171819202122232425262728293031323334package mainimport ( "fmt")/* 0 黑桃 1 红桃 2 梅花 3 方片*/func poke_sort(array []int) &#123; var kv [4]int for i:=0; i&lt;len(array); i++ &#123; kv[array[i]]++ &#125; fmt.Println(kv) var cn =0 for i :=0 ; i &lt; len(kv) ; i++ &#123; for j:=kv[i]; j&gt;0 ; j-- &#123; array[cn]=i cn++ &#125; &#125; fmt.Println(array)&#125;func main() &#123; var array = []int&#123;0,1,1,0,2,3,2,2,0,1,3,2,3,2,1,0,0,2,1,3,1&#125; poke_sort(array)&#125; 中间用了kv这个临时数组，好像不符合题目要求。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法漫步之数组某些元素求和等于目标数字]]></title>
    <url>%2F2019%2F01%2F03%2F%E7%AE%97%E6%B3%95%E6%BC%AB%E6%AD%A5%E4%B9%8B%E6%95%B0%E7%BB%84%E6%9F%90%E4%BA%9B%E5%85%83%E7%B4%A0%E6%B1%82%E5%92%8C%E7%AD%89%E4%BA%8E%E7%9B%AE%E6%A0%87%E6%95%B0%E5%AD%97%20-%20%E5%89%AF%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[题目为：给定数组元素，求数组中某些元素相加等于某个固定值。 假设数组元素为：{1,2,16,32,64,128,256} 求499 是由哪些元素相加得到的？ 例如：3 是由 1和2相加19 是由1 2 16相加131 是由 1 2 和128 相加 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109package mainimport ( "fmt" "os" "strconv")/* 求入参数字，由数组中那些元素求和可以得到*//* 传入数字和数组以及目标数字，返回由入参和数组各元素相加形成的新数组，如果数组元素与入参相加等于目标数字，则结束递归; 求和后的新数组元素没有目标数字，则用新数组第一个元素与原数组继续求和（原数组元素：原数组长度-新数组长度+1）*/func loopsum( key int, array []int,need int) &#123; l := len(array) if l &lt;1 || end &#123; return &#125; //fmt.Printf("%d+%d\n",key,array) var sum []int for i:=0 ; i&lt; l; i++ &#123; if array[i]+key == need &#123; ret = append(ret,key) ret = append(ret,array[i]) //fmt.Printf("*********key:%d ************\n",ret) end=true &#125; sum = append(sum,array[i]+key) &#125; //fmt.Println(sum) loopsum(sum[0],array[l-len(sum)+1:],need)&#125;/* 查找指定数字在数组中是否存在*/func find (key int,array []int) int &#123; for i:=0;i&lt;len(array);i++ &#123; if key == array[i] &#123; return i &#125; &#125; return -1&#125;var a =[]int&#123;1,2,16,32,64,128,256&#125;var end bool = falsevar ret []int/* 传参为目标数字 1、目标数字为原始数组成员之一，直接返回结果 2、调用loopsum查找到包含目标数字的数组，循环检查数组元素是否为原始数组，如果不是，则该元素继续调用递归函数查找该元素是哪些数字的和 3、直到返回的新数组元素都为原始数组元素成员，则目标数字由这些数字求和而得*/func main() &#123; var i int var need=131 var c=0 var res []int if len(os.Args) &lt; 2 &#123; fmt.Println("error args!") os.Exit(-1) &#125; need,_=strconv.Atoi(os.Args[1]) //要包含到hive的udf中使用，所以没有用flag if find(need,a) != -1 &#123; res=append(res,need) goto end &#125;loopfor: for i=0; i&lt;len(a)-1 ; i++ &#123; //fmt.Printf("need:%d \n",need) loopsum(a[i],a[i+1:],need) //fmt.Printf("ret:%d \n",ret) for j:=0;j&lt;len(ret);j++ &#123; if find(ret[j],a) == -1 &#123; need=ret[j] if i == len(a) -1 &#123; break &#125;else&#123; i=-1 &#125; //fmt.Printf("%d not found\n",ret[j]) &#125;else &#123; c++ //记录返回的新数组中的元素有多少个在原始数组中找到，如果全部找到，结束循环 res=append(res,ret[j]) if c == len(ret) &#123; break loopfor &#125; &#125; &#125; ret=nil end = false c=0 &#125;end: fmt.Println("find:",res)&#125; 以上是最粗暴的逐元素解构，直到所有组成元素都是初始给定的数组元素成员。优化思路，只解构一遍，然后记录解构过程，后续数字先在解构得到的树中查找，如果没有再暴力重新循环。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法漫步之二分法]]></title>
    <url>%2F2018%2F12%2F19%2F%E7%AE%97%E6%B3%95%E6%BC%AB%E6%AD%A5-%E4%BA%8C%E5%88%86%E6%B3%95%2F</url>
    <content type="text"><![CDATA[开始磨算法这本书，本书使用java作为讲解语言，因此准备对各类算法都使用golang来实现对应的功能。除了后面的搜索图论等算法，前面的算法应该实现起来都问题不大，亦步亦趋看看能做到什么地步吧。 今天前重现书中的开胃菜-二分法查找。原java代码不在搬到这里，有兴趣的朋友可以去书中提供的网址下载。点击这里 好了，我们开始，先来看看正经的字符串查找算法，如何用golang实现。1234567891011121314151617181920212223242526272829package mainimport ( "fmt" "sort")var p = fmt.Printlnfunc rank(key int,i []int) int &#123; var s=0 var e=len(i)-1 for s &lt;= e &#123; var mid = s + (e-s)/2 if key &lt; i[mid] &#123; e=mid-1 &#125;else if key &gt; i[mid] &#123; s=mid+1 &#125;else &#123; return mid &#125; &#125; return -1&#125;func main() &#123; var s=[]int&#123;11,22,33,99,88,77,55,0,3,7,3,9&#125; sort.Ints(s) p(s) p(rank(77,s))&#125; 上面是一段传统的golang代码，在s中查找数字。rank实现了二分法查找算法。二分法查找的前提是排序后的silce。按照这个思路，如果我们想在一组字符串中查找指定字符串呢？通过修改几个地方就可以实现，来看下实例。12345678910111213141516171819202122232425函数声明需要修改：func rank(key string,i []string) 变量需要修改：var s=[]string&#123;"aaa","ccc","zzz","bbb","sss","ggg"&#125;排序函数需要修改： sort.Strings(s)修改后的代码如下：func rank(key string,i []string) int &#123; var s=0 var e=len(i)-1 for s &lt;= e &#123; var mid = s + (e-s)/2 if key &lt; i[mid] &#123; e=mid-1 &#125;else if key &gt; i[mid] &#123; s=mid+1 &#125;else &#123; return mid &#125; &#125; return -1&#125;func main() &#123; var s=[]string&#123;"aaa","ccc","zzz","bbb","sss","ggg"&#125; sort.Strings(s) p(s) p(rank("zzz",s)) 来，我们继续开脑洞，如果我们想要在自己定义的一个数据类型中查找我们想要的数据呢？go的接口为我们提供了无限的可能性。我们下面实现一个在人群中查找符合年龄的人。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869定义一个自己的数据类型type Person struct &#123; Name string Age int&#125;重写sort的三个方法type Byage []Personfunc (a Byage) Len() int &#123; return len(a)&#125;func (a Byage) Swap(i, j int)&#123; a[i], a[j] = a[j], a[i]&#125;func (a Byage) Less(i, j int) bool &#123; return a[i].Age &lt; a[j].Age&#125;来看下测试案例func main() &#123; per := []Person &#123; &#123;"A",31&#125;, &#123;"B",20&#125;, &#123;"C",48&#125;, &#123;"D",18&#125;, &#123;"E",19&#125;, &#125; sort.Sort(Byage(per)) p(per)&#125;输出：[&#123;D 18&#125; &#123;E 19&#125; &#123;B 20&#125; &#123;A 31&#125; &#123;C 48&#125;] //好的，目前已经按照每个人的年龄进行了正确排序，下面我们修改二分法的方法，来实现按照年龄查找的功能接下来，我们修改rank函数func rank(key int,i Byage) int &#123; var s=0 var e=len(i)-1 for s &lt;= e &#123; var mid = s + (e-s)/2 if key &lt; i[mid].Age &#123; e=mid-1 &#125;else if key &gt; i[mid].Age &#123; s=mid+1 &#125;else &#123; return mid &#125; &#125; return -1&#125;来看我们的测试案例func main() &#123; per := []Person &#123; &#123;"A",31&#125;, &#123;"B",20&#125;, &#123;"C",48&#125;, &#123;"D",18&#125;, &#123;"E",19&#125;, &#123;"F",122&#125;, &#125; sort.Sort(Byage(per)) p(per) p(rank(31,Byage(per)))&#125;输出：[&#123;D 18&#125; &#123;E 19&#125; &#123;B 20&#125; &#123;A 31&#125; &#123;C 48&#125; &#123;F 122&#125;]3 以上，我们实现了对自己定义的数据类型进行排序，并按照自己个性化的需求查找数据。 最后，在开个脑洞，我们用多线程来做二分法查找的工作，把一个整块的数据按指定规则切分，然后多线程分别排序查找，任意一个线程返回结果，整个程序就结束。周末有空试试看。用多线程查询有个问题，就是切分后再排序，查找到的数据位置将不准确，也就是说只能知道是否找到，而无法返回其对应的位置。 —————–更新—————–测试过程中发现，对于大数据量测试，读入数据使用时长占总时长比重很大，下一版实现并发读取数据。并发读取数据涉及到多线程修改同一变量，刚好用到昨天写的锁的相关内容。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go系列(六):sync/atomic和mutex]]></title>
    <url>%2F2018%2F12%2F18%2FGo%E7%B3%BB%E5%88%97-%E5%85%AD-atomic%E5%92%8Cmutex%2F</url>
    <content type="text"><![CDATA[atomic和mutex是两种实现多线程之间通信的方式。以下我们找两段代码分别展示其用法。 sync/atomic很多场景中，我们要统计线程执行次数，此时我们需要一个简单计数器。12345678910111213141516171819202122func t_atomic_counter() &#123; var ops uint64 //go 10 threds and run 2 second for i := 0; i &lt; 10; i++ &#123; go func() &#123; for &#123; atomic.AddUint64(&amp;ops, 1) time.Sleep(time.Millisecond) &#125; &#125;() &#125; // time is end,thred is end time.Sleep(time.Second * 2) opsFinal := atomic.LoadUint64(&amp;ops) fmt.Println("ops:", opsFinal)&#125; 上面的代码调起了10个线程，执行相关业务代码，同时在线程中的for循环中调用AddUint64对ops做加1的操作。在main函数中，我们主动sleep了2秒，然后获取ops的值，看看我们在2秒内执行了多少次循环。这是一个简单的多个线程共同操作一个计数器的示例。更复杂一点的，多个线程同时修改我们自己定义的变量呢？此时我们需要用到锁的机制了，来一起看下下面的代码。 mutexmutex是互斥锁，在很多编程语言中都有用到，是控制多线程同时访问同意变量的常用手段之一。来一段实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051func t_mutexes() &#123; var state = make(map[int]int) var mutex = &amp;sync.Mutex&#123;&#125; var readOps uint64 var writeOps uint64 for r := 0; r &lt; 10; r++ &#123; go func() &#123; total := 0 for &#123; key := rand.Intn(5) mutex.Lock() total += state[key] mutex.Unlock() atomic.AddUint64(&amp;readOps, 1) time.Sleep(2 * time.Millisecond) &#125; &#125;() &#125; for w := 0; w &lt; 5; w++ &#123; go func() &#123; for &#123; key := rand.Intn(5) val := rand.Intn(999) mutex.Lock() state[key] = val mutex.Unlock() atomic.AddUint64(&amp;writeOps, 1) time.Sleep(2 * time.Millisecond) &#125; &#125;() &#125; time.Sleep(3 * time.Second) readOpsFinal := atomic.LoadUint64(&amp;readOps) fmt.Println("readOps:", readOpsFinal) writeOpsFinal := atomic.LoadUint64(&amp;writeOps) fmt.Println("writeOps:", writeOpsFinal) /*no uesed.emmm....*/ //mutex.Lock() //确保主线程可以获取到锁 fmt.Println("state:", state) //mutex.Unlock()&#125; 代码最开始，先声明了几个变量，两个计数器、一个互斥锁，一个map。然后用100个线程取求state这个map中值得和，用10个线程取填充state这个map。在两个线程中，会出现同时操作state这个map的时刻，因此在操作之前要分别加锁，先获取锁，再操作state，然后再释放锁，以此来保证同一时刻只有一个线程拥有操作state的权限。这段代码中也用到了atomic的方法来记录我们读\写的次数。但是这种方法效率有时候并非很高，可能很多资源都用在了争锁上，尤其是单机运行时，这种情况会更明显。当然，也有更好的解决办法，比如我们读的时候用只读锁等等。 简单复习了两种多线程之间的通信方法，更复杂的以后再继续更新。下一节要复习interface这个特殊的类型。interface是一种特别的数据类型，在golang的源码中可以说是遍地都是，下一节我们一起来学习这个神奇的类型。]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go系列(五):Goroutines]]></title>
    <url>%2F2018%2F12%2F12%2FGo%E7%B3%BB%E5%88%97-%E4%BA%94-Goroutines%2F</url>
    <content type="text"><![CDATA[并发编程是golang基因中就支持的特性，而且十分的方便好用，很多其他编程语言中的并发控制和通讯都及其便捷。 关键字gogolang中调用函数1234f() //call f() ;wait for it to returngo f() //go的线程来了（严格说和线程是有区别的，姑且这么叫着），不等f函数的返回 golang的并发编程就是这么简单，本节完。等等…还有一点。 多线程之间的通信之channel无缓冲channel的每次发送和接收发生在不同的线程中，由此来达到数据同步或通信的目的。来一段实例12345678package mainimport "fmt"func main() &#123; messages := make(chan string) go func() &#123; messages &lt;- "ping" &#125;() msg := &lt;-messages fmt.Println(msg)&#125; 上面的一小段示例用到了匿名函数，函数体很简单，向messages中写入一个字符串，然后再main中读取出来。这样主线程和go调起来的线程就进行了一次简单的数据同步动作。 再来，我们用channel来实现等待线程结束，然后主线程退出的功能。 123456go func() &#123; //do something..... done &lt;- true&#125;()&lt;-done //阻塞等待子线程完成 go调起来的线程可以做很多事情，只要退出前向管道中写入字符串表示工作完成，然后在主线程中读出字符串。 再来，来一个线程池，同时并发多个子线程完成工作。 123456789101112131415161718192021222324252627282930313233func t_worker_pool(id int, jobs &lt;-chan int, results chan&lt;- int) &#123; for j := range jobs &#123; fmt.Println("worker", id, "started job", j) time.Sleep(time.Second) fmt.Println("worker", id, "finished job", j) results &lt;- j * 1 &#125;&#125;func t_pool() &#123; jobs := make(chan int, 100) results := make(chan int, 100) //thread nums for w := 1; w &lt;= 7; w++ &#123; go t_worker_pool(w, jobs, results) &#125; //job nums for j := 1; j &lt;= 20; j++ &#123; jobs &lt;- j &#125; close(jobs) for a := 1; a &lt;= 20; a++ &#123; &lt;-results // ensure all jobs is finished &#125;&#125; t_pool 函数中调起7个子线程，完成job，并接受其返回的结果。t_worker_pool 是其具体实现，循环读出jbos队列中的信息，然后将结果写入results。t_pool第二个for循环，作用是分配20个job，分配完成后关闭jobs队列。 然后循环等待所有results都被写入内容。实现了使用7个线程完成20个job的功能。 多线程之间通信，除了channel还有sync/atomic包实现多线程共享变量，以及 mutex 实现更复杂的多线程之间变量互相访问，这些内容我们下一节再聊。]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go系列(四):函数和方法]]></title>
    <url>%2F2018%2F12%2F04%2FGo%E7%B3%BB%E5%88%97-%E5%9B%9B-%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[主要介绍golang的函数，包括声明方式、多返回值特性、匿名函数等。 函数的声明我们从源码里粘一段声明出来示例。1234func Reverse(data Interface) Interface &#123; return &amp;reverse&#123;data&#125;&#125; 这是sort函数中的一段反转字符串的代码，其中func是关键字、Reverse是函数名、data 是入参名、括号内的Interface是入参的类型、括号外的Interface是返回值得类型。以上就是构成一段完整的函数声明需要的所有元素。 函数名称大小写的问题，可以参考golang代码规范。 其中入参和返回值的类型可以是任何合法的数据类型，结构体、数组、slice、map、channel、int、string等等。 来，接下来我们粘一段方法的声明方式，很相似，所以放在一起看一下，防止概念不清楚。 1234// Less returns the opposite of the embedded implementation\'s Less method.func (r reverse) Less(i, j int) bool &#123; return r.Interface.Less(j, i)&#125; 来一起看Less这个方法的声明，同样有入参、返回值、方法名、与函数唯一不同的地方在于，方法名前有r reverse，这个r的含义是，该方法是被reverse类型的变量调用调用方法如下：123456789101112131415type reverse struct &#123; // This embedded Interface permits Reverse to use the methods of // another Interface implementation. Interface&#125;func IsSorted(data Interface) bool &#123; n := data.Len() for i := n - 1; i &gt; 0; i-- &#123; if data.Less(i, i-1) &#123; return false &#125; &#125; return true&#125; 看data.Less，这里data是一种特殊的数据类型–接口，我们在以后再细说。如果这个例子不太形象，我们再来看下一个，出自golang在线教程中的一段代码。12345678910111213type rect struct&#123; width,height int&#125;func (r *rect) area() int&#123; return r.width*r.height&#125;func t_main() &#123; r := rect&#123;width:10,height:5&#125; fmt.Println(r.area())&#125; rect是一个结构体，r := rect{width:10,height:5} 定义了r是rect结构体，并为他的成员分别赋值10和5,r.area() 调用area这个方法，计算面积。这个例子应该很形象了，如果我定义一个int型数组的变量来调用该方法呢。1234567func main() &#123; r := rect&#123;width:10,height:5&#125; a := []int&#123;1,2&#125; fmt.Println(a.area())&#125;# command-line-arguments./hi.go:17:18: a.area undefined (type []int has no field or method area) 会报undefined的错误，解释为我们没有给int数组定义一个area的方法，所以不能调用。 方法和函数的区别到这里应该清楚了，下面看几个golang函数的特性。 多返回值多返回值和defer是golang设计的神来之笔，太牛了，golang函数一般会返回两个值，一个是期望得到的返回值，一个是错误信息，我们继续扒源码看一下。 1234567891011func (s *SectionReader) Read(p []byte) (n int, err error) &#123; if s.off &gt;= s.limit &#123; return 0, EOF &#125; if max := s.limit - s.off; int64(len(p)) &gt; max &#123; p = p[0:max] &#125; n, err = s.r.ReadAt(p, s.off) s.off += int64(n) return&#125; 这是io中的一段源码，Read函数返回了两个值，一个是读的字节数n，一个是错误信息err，接收也很简单，就像n, err = s.r.ReadAt(p, s.off) 这个函数一样，一个变量接收字节数，另外一个变量接收错误信息，如果不需要错误信息，也可以用丢弃变量 n, _ = s.r.ReadAt(p, s.off)。 这个设计妙在既可以又可以的地方，比如写入文件，也会返回两个变量，写入字节数和错误信息，我们完全可以得到已经写入多少字节，以及出现了什么错误。写到这里，我想到断点续传的功能，用golang实现可以说是非常简单了。 匿名函数匿名函数，并不是golang的特权，python的lambda也是类似的功能。来一起看一下 12345678func (p *pipe) CloseRead(err error) error &#123; if err == nil &#123; err = ErrClosedPipe &#125; p.rerr.Store(err) p.once.Do(func() &#123; close(p.done) &#125;) return nil&#125; 上面这段代码中 p.once.Do(func() { close(p.done) }) 包含一段匿名函数，有func关键字，没有函数名称{}包围了实现功能。类似这样的用法就叫匿名函数 可变参数可变参数也不是golang独有的特性，其中C语言中也有类似的实现。不过c语言的可变参数是通过一个系统定义好的数组存储的，golang可以直接自己用循环遍历。最常用恐怕就是fmt中的println函数了，我们来扒一下它的源代码。 1234567891011121314151617181920212223// Fprint formats using the default formats for its operands and writes to w.// Spaces are added between operands when neither is a string.// It returns the number of bytes written and any write error encountered.func Fprint(w io.Writer, a ...interface&#123;&#125;) (n int, err error) &#123; p := newPrinter() p.doPrint(a) n, err = w.Write(p.buf) p.free() return&#125;func (p *pp) doPrint(a []interface&#123;&#125;) &#123; prevString := false for argNum, arg := range a &#123; isString := arg != nil &amp;&amp; reflect.TypeOf(arg).Kind() == reflect.String // Add a space between two non-string arguments. if argNum &gt; 0 &amp;&amp; !isString &amp;&amp; !prevString &#123; p.buf.WriteByte(' ') &#125; p.printArg(arg, 'v') prevString = isString &#125;&#125; 其中 a …interface{} 表示是个可变的参数，且是接口，又看到了这个特殊的类型，我们继续跳过，假装它是一个普通的数据类型就好。在doPrint中用for argNum, arg := range a循环变脸参数列表，argNum表示参数下表，arg是参数值。 以上是可变参数函数的定义和使用的基本方式。 defer panic recoverdefer是golang另外一个神技，defer后跟的语句，在运行结束的最后才运行，经常用在释放资源、关闭文件等操作。大大减少了代码中到处的错误检查和资源释放。 123456789101112131415161718192021222324252627282930313233func (fs *fileStat) loadFileId() error &#123; fs.Lock() defer fs.Unlock() //当函数运行结束时，释放锁 if fs.path == "" &#123; // already done return nil &#125; var path string if fs.appendNameToPath &#123; path = fs.path + `\` + fs.name &#125; else &#123; path = fs.path &#125; pathp, err := syscall.UTF16PtrFromString(path) if err != nil &#123; return err &#125; h, err := syscall.CreateFile(pathp, 0, 0, nil, syscall.OPEN_EXISTING, syscall.FILE_FLAG_BACKUP_SEMANTICS, 0) if err != nil &#123; return err &#125; defer syscall.CloseHandle(h) //当函数运行结束时，关闭文件句柄 var i syscall.ByHandleFileInformation err = syscall.GetFileInformationByHandle(h, &amp;i) if err != nil &#123; return err &#125; fs.path = "" fs.vol = i.VolumeSerialNumber fs.idxhi = i.FileIndexHigh fs.idxlo = i.FileIndexLow return nil&#125; 释放资源的语句紧跟在资源获取语句之后，后面无论代码如何运行还是报错等等，defer语句都会在最后执行。其余的错误判断中无需做任何特殊处理。 panic 实现类似asset的功能，报错直接退出，但是它的报错信息不是特别友好，简单看下它的使用方法。1234567891011121314151617181920func init() &#123; if e := os.Getenv(executable_EnvVar); e != "" &#123; // first chdir to another path dir := "/" if runtime.GOOS == "windows" &#123; cwd, err := os.Getwd() if err != nil &#123; panic(err) //报错退出 &#125; dir = filepath.VolumeName(cwd) &#125; os.Chdir(dir) if ep, err := os.Executable(); err != nil &#123; fmt.Fprint(os.Stderr, "ERROR: ", err) &#125; else &#123; fmt.Fprint(os.Stderr, ep) &#125; os.Exit(0) &#125;&#125; 由于panic报错信息很不友好，我们又有了recover函数，用来恢复现场，恢复错误发生时的堆栈信息，还原错误场景。recover通常和defer一起使用，当程序崩溃的时候触发 12345678func TestNewTickerLtZeroDuration(t *testing.T) &#123; defer func() &#123; if err := recover(); err == nil &#123; t.Errorf("NewTicker(-1) should have panicked") &#125; &#125;() NewTicker(-1)&#125; 当defer函数发生了panic异常，recover会使程序从panic中恢复，并返回panic value。导致panic异常的函数不会继续运行，但能正常返回。在未发生panic异常时调用recover，会返回nil。以上是golang一些特殊的技能，下一节一起来看看golang最强的goroutines]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go系列(三):new和make]]></title>
    <url>%2F2018%2F11%2F29%2FGo%E7%B3%BB%E5%88%97-%E4%B8%89-new%E5%92%8Cmake%2F</url>
    <content type="text"><![CDATA[make 和 new 都用作初始化变量，区别有以下几点。 原型分别如下：1234567891011121314151617181920212223// The new built-in function allocates memory. The first argument is a type,// not a value, and the value returned is a pointer to a newly// allocated zero value of that type.func new(Type) *Type// The make built-in function allocates and initializes an object of type// slice, map, or chan (only). Like new, the first argument is a type, not a// value. Unlike new, make's return type is the same as the type of its// argument, not a pointer to it. The specification of the result depends on// the type:// Slice: The size specifies the length. The capacity of the slice is// equal to its length. A second integer argument may be provided to// specify a different capacity; it must be no smaller than the// length. For example, make([]int, 0, 10) allocates an underlying array// of size 10 and returns a slice of length 0 and capacity 10 that is// backed by this underlying array.// Map: An empty map is allocated with enough space to hold the// specified number of elements. The size may be omitted, in which case// a small starting size is allocated.// Channel: The channel's buffer is initialized with the specified// buffer capacity. If zero, or the size is omitted, the channel is// unbuffered.func make(t Type, size ...IntegerType) Type 主要区别： make将变量值初始化为0，而new只是为变量分配了一块内存，返回指向分配地址的指针； 使用范围不同，make用在slice、channel、map（slice、channel、map 只有在初始化后，才可以使用），new可以给所有类型分配空间 eg:1234567891011121314v := make(map[string] string) //声明一个mapv := make([]string,10) //声明一个slicev := make(chan string) //声明一个channelnew的示例type T_new struct &#123; name,sex string&#125;三种方式都能正常使用r1 := new(T_new) // &amp;&#123; &#125;r2 := &amp;T_new&#123;"a","b"&#125; // &amp;&#123;a b&#125;r3 := T_new&#123;name:"a",sex:"b"&#125; // &#123;a,b&#125;r4 := T_new("a","b") // &#123;a,b&#125; make和new是容易混淆的概念，其实把函数原型放出来看一下，就明白了两者的区别，放一起比较使用，会更清晰一点，下一节写 函数声明和方法声明]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go系列(二):数组 map slice]]></title>
    <url>%2F2018%2F11%2F27%2FGo%E7%B3%BB%E5%88%97-%E4%BA%8C-%E6%95%B0%E7%BB%84%20map%20slice%2F</url>
    <content type="text"><![CDATA[golang 中数组、slice、map都属于collection类型，大概就是分出一片空间存储一堆的数据。 他们的主要区别： 数组有长度，slice没有， map是无序的，数组和slice有序 数组和slice下标数数字，map的key是任意等值性类型 数组的三种声明方式:123456var i [10]inti[0]=1var i=[10]inti:=[10]int 数组是值，数组间复制相当于复制了一个数组副本数组作为参数传入函数，函数收到的也是数组的副本，而非指针（地址）数组的大小是类型声明的一部分，不可或缺 slice的声明方式： 1234567891011var i []int //这里的i就是没有长度的slice了初始化:var i []type=make([]type,len) //len是切片的初始长度或i := make([]type,len)i :=[] int&#123;1,2,3&#125;i := arr[:] //arr是一个数组 :两侧可以写数组下标，表示数字的0~len的值Tips:make 和new 都是初始化slice的一种方式，他们的区别下一节再写 map的声明方式:12345678var i_map map[key_type]value_typevar i map[string]int //声明了一个map，但还无法使用，必须初始化以后才能使用i=make(map[string]int) //初始化map，初始化后才可以存储数据i_map := make(map[string]int) //另一种方式，省略var关键字，但是只可以在函数内部使用i_map :=map[string]int&#123;"key1":1,"key2":2&#125; //直接初始化使用 今天用了make方式初始化了slice和map，golang中还有new方法也是初始化变量，其中某些区别下一节再细聊。]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go系列(一):变量声明]]></title>
    <url>%2F2018%2F11%2F26%2FGo%E7%B3%BB%E5%88%97-%E4%B8%80-%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%2F</url>
    <content type="text"><![CDATA[golang 整体看起来像是like c风格，常用变量类型有 1int string array map slice 等 变量声明方式有以下三种： 1、var 变量名 变量类型 (可用作全局变量声明) 2、var 变量名 = value，自行判定变量类型 3、省略var 变量名:=value，自行判定变量类型，只能用于函数内部，不可用作全局变量声明 示例:123456var i_int int i_int=3var i_int=3i_int:=3 多变量声明123456789101112var name1 name2 name3 type name1,name2,name3 = v1,v2,v3(var name1 type1=v1)var name1,name2,name3 = v1,v2,v3name1,name2,name3 :=v1,v2,v3var ( name1 type1 name2 type2) //常用语全局变量声明 特殊变量 _常用语接收代码不需要的变量，是一个only read 变量，如果代码中某个变量声明但未使用，代码编译会报错，这时可以使用_接收变量，绕过这个error。12345func main()&#123; var a int =1 //fmt.Println(a) _ =a&#125; 下一节：array、map、slice的使用]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F11%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[E大博文链接合集]]></title>
    <url>%2F2018%2F11%2F26%2FE%E5%A4%A7%E5%8D%9A%E6%96%87%E9%93%BE%E6%8E%A5%E5%90%88%E9%9B%86%2F</url>
    <content type="text"><![CDATA[2009年北京市职工年平均工资为48444元 再谈可转债 黄金ETF也将是未来ETF计划配置的一份子 倒计时：921天 你敢在舒服点的地方睡吗 我们一起追火车 近期市场观察+整体趋势和整体价值 第一期建仓完毕 巴菲特降至半仓的启示 近期最有意思：国债收益飙升 无法下手 嗯。。 2011.09.24 资本市场真相记录：股民号召股民清仓销户，永远退出股市 金戈铁马，号角吹响了 注册制 男性健康日 不投资，你的存款在银行会变成渣 etf计划的2011 新庄股 从容 今日研究&amp;强烈关注 转债的卖出时机 从另一面说说QDII 一个决定 本月两份+送给新加入的朋友几句话。 冲向20 本月依然：0 2011.1.9 投资周记+谈谈信李驰 中证消费10年来大致pe 人生 I 十个人的“微表情”：私募大江湖的小小缩影 今天有场大战役/没搞满！ 其实最重要的是：常识 我的偶像给比尔盖茨夫妇的信 我为鑫利数日子(2012-8-30 : 归一，结束)——0.98金利清仓 发两张图，欢迎大家讨论。 201506：本月卖出3份，买入2份 基金2010年上半年业绩统计报告 鲁泰半年报 拭目以待 再见，2011 即日起，ETF计划加入四只新的品种 2011前三季度将要过去，总结etf计划过去21个月的表现 2007启明基金大的投资策略 让我舒服的持仓：2012-05-04 乌云盖顶 BDI再回前期高点、PMI重上50 NEW PP 如果我们的etf计划是公募，将会很风光 每天a类精彩大戏不断，没精力一个个说了 持仓变化 关于估值的一点想法 年终投资回顾一：定投计划开门红，战胜大盘27% 风光的背后：真相能否让你领悟？ 建行翻番了 吃一堑要长一智 送给新朋友的几句话 日本09年人均月薪创历史最大降幅 预告：虽然最近越来越忙，但有几个题总想写一写 下一个目标：工行转债 又捐了 长跑 照常理，这应该是一篇耻辱柱——2011投资策略大探市 30家券商巨头纷争牛熊 你永远猜不透市场 2011年第4-7本好书——《投资者的未来》及其它 浅谈资产再平衡 网格转债 资产下跌之后的心态 房地产股能不能买？ etf计划有意思的数据 PE|PB跟踪更新帖(2012.12.03：pb\pe再创新低：pb 1.94！) 割掉毒瘤 让利润奔跑 各种量化投资计划电梯 谢谢你，忘了3000点吧。 写给“zhtgyl”——商讨ETF计划的一些问题 1st day CPI 嗯。 新题目：去超市败家的同时买超市 推迟满足感 1/3了 机器人 大道相通 我爱基金 遭受挫折，决定学坏 AH股溢价指数首次破百 A股迈入“折价时代” 2011年第26周好书——赛斯卡拉曼：《安全边际》 超级无敌大熊市？不识庐山真面目，只缘身在此山中 现金为王 中行转债 再见2012，我会怀念你 投资到底有多难？ 2013.02 本月买卖份数：0+两个记录诞生的背后 基金三季度新增前20大重仓股(按市值排序) 成功的投资到底靠什么？ 本月买入一份（11.08.01） 小统计 社保基金个人账户年均收益率18.9%——未来将异常惨烈 到底什么是金融投资 饺子 公司债暴跌，是否有机会？ 可爱的公募基金——基金踏空此轮行情 后市面临调仓压力 似乎只有中国资本市场在承受金融危机后遗症 黄金、白银T+D 医药 拨开股市的迷雾——到底是什么决定了涨跌 最近盯的机会 阳光私募半年成绩单出炉 明星陨落新军突起 持仓A类一览 开始关注A类 2011年第28周好书——《巴菲特致股东的信1957-2010》 加博友/10.04修改添加方法 网格第四轮清仓完毕 顺藤摸瓜找出的好文章：择时交易的小概率困境 再说资产配置 2009年10大熊股 10看好 你比82.45%的基金经理强 什么是真正的价值投资 …… 封闭式基金已经进入极度可投资区域 周末，我家窗外… JOEY之死 定投收益的预期收益率应该是多少？ “墨菲定律”： 再顺便上几张照片吧，两周前拍的。 短线将发生一些有意思的事情 年底回来看成败：四成专家认为明年上证指数将超过3500点 清仓A类 这轮反弹以来，别人都赚了多少？ 整体估值一览，记录疯狂年代 中国的股民比我想象的还可怕：今年居然有61%的人亏损 此时此刻，我们的A股是不是“历史估值最底部”？ 买车股好过买车 11.10.19 资本市场真相记录:银行持续两年pe不到10倍，股市真的是无效的？ 复杂系统中，会发生很多不可预计的事情 ETF计划所有品种全面翻红 4月输了 5月新起点 投资长赢的真谛 BDI、上证指数和中海发展 写字ing 同辉100A 从建行贷款然后买建行股票 ETF计划中的中小ETF、500ETF创2年新高 所谓人生好时节… 再说杠杆 估值、趋势以及未来策略 2010年度总结（投资篇） 乱弹历史——四大发明之一：活字印刷术 赔死你们这些抢反弹的！ 挺有意思的一个新闻 暴风雨的前夜 卖出一份 万事皆可解决 半仓了 关注H股A TVB常见台词 本周好书推荐：《金融的逻辑》 做了张图，希望大家热烈讨论 调整中的加仓位置 简单惊人的“M1定买卖”投资法 换了主题，囧 拉登与中国的股市、楼市 爱之韵 降息？I don’t care da shi say 记录一件事情，发表一个感慨 开始大幅超越指数+2份 很多东西不在这里写了。朋友可以去雪球关注 只涨了一天,pe就没法看了 百年孤寂的投资女神 简单执着，见证投资传奇 鑫瑞现价1.345，溢价过多。出货 下跌不远了 华宝油气两轮网格完毕 猎人 ETF计划 Q &amp; A (13.10.21更新Q4) 3rd day 一切按照剧本行动 PB和scofiled的粉丝们看了这个广告 新年第一个月：卖出一份 消费etf已入仓位配置 股票？真没啥可看的了 中国股市也属于地球 三论金利收益 刚看了看etf这两周的收益，又看了看好买的基金排名，我彻底无语了 请注意债券收益率 2010.12.04 市场观察周记 大概说说etf分红 今天，我来谈谈预期收益率 google,我服了你了 ETF+金利的投资逻辑 关于etf计划收益率的计算，最后一次阐述 冤枉招行了 穷人与富人的不同思维 M 本人现阶段资产配置表 你炒股吗 我们都会在资本市场取得我们应得的收益 看了上一贴的评论，感觉是万万没想到 给苹果——金利为何一路下行 十券商策略报告准确率仅47% 申万最准海通垫底 好吧，谈谈个股 2011，困难的一年 顺大势而为 启明基金一期顺利结束，二期开始运作 本月卖出3份 指数还在半山腰，四成个股已新高 也许这才是老美不停新高，老A牛短熊长的根本原因 关于量化交易的几个问题，欢迎大家积极讨论 预祝所有博友新年快乐！ 用行动鉴证价值 华宝添益2天年化收益率超过20% 学习的力量 价值投资——今日再涨停 2张图让你看懂中国投资者，争取每周更新 没有机会的日子只能等待 人的一生，就像乘坐一辆公交车 读书心得【贰】：自我价值与别人的赞许 同瑞开始涨 大风起兮猪飞扬 今年的大机会在哪里 1.39卖掉剩下的20%，清仓鑫瑞 鸭子 只渡有缘人 不买汽车买汽车股第一期结果 有没有博友愿意为大家做道题？ 关于针对标普500与恒生的一些投资想法 财神助威 今天开始 现阶段持仓比例 门票策略盘（更新完毕） 大家误会了 继续兴奋 深机转债也不错 握紧你的筹码 南山转债是股还是债 and 稳进和金利又开始犯2 投资大师的长寿 动态再平衡组合 2012那一天… 第二只公布股 创A已清仓。 他们再次预测：下半年上证指数将达3500点 医药、消费即将上市 2nd day 越看书 越纠结 关注日元 安全边际 不详的预感 920，+1关注 别人狂热你冷静，别人恐惧你继续冷静 从历史看未来 不玩了。关注A股的同学近期不必来这里了 不出所料 上周交易户数\持仓户数简评 转债最关键的几个价位 有些人可以帮你评价估值 再帖一次 回答“百志惟熙”朋友关于etf的几个问题 同学们，来来来，都冒个泡 我们财富的过去、现在和未来（历史篇） 我会买的股票 查阅美国人寿公司市值，翻出疯狂的年代 大跌眼镜 门票目标，2015第一季全出炉 改了 给某位网友： 我啥都不想说了。。 套利华宝添益 混沌的估值结构 选品种——底部到来之前的风险与收益 网易帐户密码被盗 给“yuup”，出租小房子好还是金利好 网格操作记录——2014.11.28 3.22 卖出 彻底清仓 关于同辉100A未来三年收益率 投资，就是一部挑战人性的修炼史 我的股票池 全部盈利 本月卖出一份 先不写了 简单生活 100etf持仓明细：这些好公司可以一次全都持有，别无所求了 一个回顾 价值股。净资产收益率每年&gt;10 余额宝完成了我的一个梦想 好日子总是消失的很快 2015 网格计划一：恒生 / 15.01.13 首笔获利完成 套利交易 一篇新闻+几个数据，请大家自己思考投资的奥义 全球银行市净率排行4中资行挺进前五 无股可买的巴菲特 去年赚了73亿美元 今年看起来会延续盈利 很少转载文章，今天转载一篇：人民财评：股市散户疯狂原因何在？ 基金大佬竞相上马行业系列ETF 7家大公司推出 停止黑嘴 张老板和弘毅已经解套 大戏会上演吗 金利历史新高，笑看风云 ETF计划再次开始盈利，战胜同期97%股票基金 低风险高收益——现阶段投资金利、稳进、500a的可行性分析 又一次买在最低 非常简单的第一次行业pe统计 回来了+中国经济硬着陆 在这个浮躁的时候，推荐大家看两本书 … 整个中国股市被一部动画片占领了 五福临门 一则小声明 如何积阴德之几件小事 企业盈利确实在下降 一字头后的市场数据——决战的号角即将吹响 新的计划 上一期的定投计划回报情况，留作纪念 跑赢大盘的复利意义 7% 使你的后悔最小化 不是正式的心得 只有两种可能 无人纪念 平心而论，炒股还有意义吗？ 第三次回顾 你我如果没有梦想，那么跟一条咸鱼有什么区别？ 以投资实体经济的理念来投资股票 博汇转债 中证全指七行业历史pe 新钢转债 轻松踏上理财之路 本月买入一份 赤子之心，于我心有戚戚焉 2010.12.12 市场观察周记 不得不说，欧债危机开始升级了 行情总是在绝望中产生，在犹豫中发展 为什么整体市盈率很重要 开始真正的长期投资 跑赢大盘 记录历史的一刻。 再次关注可转债 惜福、习牢、持戒、自尊 本月不买不卖 截止11:30，pe到了33.5 88888 该写点东西了 攻守相宜可转债 卖掉一半，笑纳利润 看电视，无语 关于“生”和“死” 第一笔建仓完毕 欢迎添加公众号 现阶段的套保思路——给偏保守的朋友 人生 II 关于同辉100a的买入价格 突然明白的一件事 价值投资 截至今天，今年你再次战胜了80%多的基金经理 从分红角度计算中海发展的投资价值 可怕的pe 卖出部分华安石油 机会慢慢出来了 友情提示：有转债的同学赶紧清理干净 BDI重新跌至916点 福缘 下周会大跌 ETF计划的两个小数据 必须说点什么了 欢迎大家讨论合适抄底的标的物 采纳博友意见，给各指数pe值 什么是幸福 提醒 婚姻和股市 飞跃疯人院 行业PE\PB统计计划正式启动 宏观经济、A股和上证 散户怎能不死？这样操作你不死谁死？？？？ 你是来炒股的，还是来赚钱的？ 中国股市的估值到底是多少？ 五一游记 狗的礼赞 2010年05月24日 A类大戏即将上演 好文共赏——人生不同阶段的投资规划 即将进入死亡之顶 五年最牛公司实盘试验 恩 情绪变化导致机会不断出现 年底了，这几天打算写个长点的东西。 最新结构 同学们，你们账户里真的清干净了？ 投资近六年来给我赚钱和赔钱最多的股票 锐进低折后 机会，跌出来了 这应该算是开了吧。 2011年11月——本月买入2份 我们的tenbagger 今日DCSX指数 帮一个朋友算的，顺便贴出来 12月定投：卖出一份 很黄，很暴力。。。 六一儿童节 如何化解2008年犯太岁(马、鼠、兔、羊)必看 持仓帐户增加了 180的逆袭 180etf分红 。 big money 史无前例的金融时代 还有没有A类亏损的朋友了？ 试验新的量化模型 还能拿多久？ oops… 巴菲特的最新持股——送给认为巴菲特就是买入不动的人 价值投资区域 油气网格开始 投资 研究贴：各大指数的十大权重股 2011.4 等待8个月后，终于——买入一份 不论公募、私募还是散户、机构，希望主动长期超越市场都是妄想 2008 周五收盘前操作的理由 恭祝大家龙年吉祥！ 利率应该怎么用 江晖：践行绝对收益之率之路！ 一封信 虽不为僧，大义相通 买卖的节奏 比较开心 晚安，2010 - 修罗的2010纪念册 两个数据，一个结论 截止今日，所有参加etf计划的朋友都盈利了 518880 再次总结ETF计划总收益、分年度收益以及与各类基金对比 他们增持了，你呢？ 本月两份 油气每日净值预测 2011年第30周好书——《财报就像一本故事书》 日元暴涨3% 2000点说仓位 趋势账户，招行依然不给力 最需要得到的 15年前的5月21日 2011.10.16 资本市场真相记录：送气工3000元变600万 真相并不重要 上市公司企业利润确实在下降，但降幅非常有限 无耻的上交所 且行且珍惜 etf的特大喜讯，终于来了 中国股市问题之一是散户太多 应博友要求贴出pe 做一个自由支配自己与其时间的贵族 2011.05 买入一份 2011.1.20投资周记 投资 性格最重要 买鑫利的脑残再次出现了 写在这个伟大的日子 寻找明珠系列 1：鲁泰 随便说说股票 关于大盘 转载难得一见的好文章——经济的“中国模式”走向终结 判断题：我们现在处在哪个阶段？ 关于中行转债 定投是否真的如此美妙 加息 2008哪些人犯太岁以及化解太岁的方法 柳暗花明 倒数 快与慢 2011.02。 本月不买不卖+我们的投资未来 今天在开心网上看到一个题，挺有意思。。 停止谈论个股 为别摸我买了第一年的保险 买基金的人，胆子最大了 趋势与价值 上一个十年的大牛股是谁，下一个十年的大牛股在哪里 什么时候卖股票 随手存数据——壹 深市成交额十年来首超沪市 资金从大盘股中撤离 不成熟的想法，从M1数据来考虑 怎能不得瑟？ 跌了，看着就舒服多了。下个月可以继续买了 持仓帐户连续新高后，2513，开始有人割肉了 两个小寓言 权作留念 上周交易户数、持仓户数简评 毒贩住在父母家里 港股的诱惑 ETF计划的好消息 记录现在，受益未来 联合国说 继续记录成绩 慢慢的开始激动起来 怎么战胜通胀 支持HH 珠三角缺工超200万人：部分生产线已处停工状态 版权归ETF拯救世界所有，不得用于盈利性目的]]></content>
      <categories>
        <category>E大博文</category>
      </categories>
      <tags>
        <tag>经济</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[书单备忘录]]></title>
    <url>%2F2018%2F11%2F24%2F%E4%B9%A6%E5%8D%95%E5%A4%87%E5%BF%98%E5%BD%95%2F</url>
    <content type="text"><![CDATA[已读清单： 缠中说禅天才在左，疯子在右：精神病人采访实录浪潮之巅：各大科技公司历史简述大癫狂：群体性狂热与泡沫经济，人性从未改变查理·芒格的智慧：投资的格栅理论（原书第2版）查理·芒格的原则彼得·林奇的成功投资（珍藏版） (华章经典·金融投资)投资者的未来 行为投资学手册：投资者如何避免成为自己最大的敌人秦朔访问以交易为生(珍藏版) (华章经典•金融投资)股票大作手回忆录(修订版)通向财务自由之路(原书第2版•珍藏版) ：构建完整交易系统必读股票大作手操盘术:融合时间和价格的利弗莫尔准则穷查理宝典：查理·芒格的智慧箴言录笑傲股市(原书第4版) (华章经典•金融投资)纳什均衡与博弈论股市真规则自律的交易者思考，快与慢习惯的力量（精编图文版）反脆弱:从不确定性中获益金融心理学低风险投资之路手把手教你读财报:财报是用来排除企业的邓小平时代滚雪球腾讯传投资最重要的事投资最不重要的事干法穿越迷雾：巴菲特投资与经营思想之我见颠覆者：周鸿祎自传华章经典·金融投资 投资心理学（原书第5版）怎样选择成长股（珍藏版）投资的护城河 晨星公司解密巴菲特股市投资法则乌合之众：群体时代的大众心理（精装插图版）-“慢读”系列学会估值，轻松投资 [美] 阿斯沃斯·达摩达兰 中信出版社图书跳着踢踏舞去上班指数基金投资指南止损：如何克服贪婪和恐惧（经典好书，简析交易心理）黑天鹅 如何应对不可预知的未来（升级版）量价分析：量价分析创始人威科夫的盘口解读方法股市天才：发现股市利润的秘密隐藏之地（无聊的书）股票短线交易的24堂精品课：超越技术分析的投机之道（第二版 套装上下册）百箭穿杨超额收益：价值投资在中国的最佳实践投资第一课低风险投资之路（第2版）江恩测市法则（第2版）鲁兆股市预测与实战操作系统人格心理学（第七版）（万千心理） 每天学点管理学全集 正在阅读：选择的悖论:用心理学解读人的经济行为原则人类简史逃不开的经济周期：历史，理论与投资现实时运变迁：世界货币、美国地位与人民币的未来 未读清单：重来清醒思考的艺术简单逻辑学算法数据库索引设计与优化高性能MySQL（第3版）战争风云：二战回忆录现代经济学大典：产业经济学分册（太枯燥了….）下一场全球金融危机的到来 明斯基与金融不稳定（太枯燥了….）货币的祸害大国政治的悲剧走向繁荣的战略选择]]></content>
      <categories>
        <category>书单</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[markdown语法说明]]></title>
    <url>%2F2018%2F11%2F21%2Fmarkdown%E8%AF%AD%E6%B3%95%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[你能看到这篇文章，说明你基本已经知道markdown是什么了，所以我们直奔主题。 markdown的基本语法非常简单，分为： 标题，段落，区块引用，代码区块，强调，列表，分割线等。 No1.标题用 = 和 - 标记一级和二级标题，效果如下一级标题（在这串文字下方加=====）二级标题（在这串文字下方加—–） No2.使用#可以表示1-6级标题，一个#表示一级标题，以此类推，注意#和文字之间有空格，效果如下一级标题二级标题三级标题四级标题五级标题六级标题No3.区块引用，在段落的每行或者只在第一行使用符号&gt;，嵌套引用就用多个&gt;，如:&gt;&gt;，效果如下 这里是区块引用 这里是嵌套引用 No4.代码区块（TODO-LIST）No5.强调，在强调的两侧加*,**表示斜体，****表示粗体斜体粗体 No6.列表，使用 * + -标记无序列表，有序列表的标记方式是将上述符号换成数字，并辅以. 第一项 第一项 第一项 第一项 第二项 No7.分隔线常用的是三个或以上*、-、_,三个效果相同 No8.链接有两种形式，行内式和参考式，链接需要是完整的行内式：[文字](链接) 参考式： [文字1][1] [文字2][2] [1]:这里是链接，页面不会直接显示 [2]:这里是链接，页面不会直接显示 效果如下： google 这里只有行内式的，因为参考式的我调不出来….. No9.图片链接，和上述添加链接相似，需要在链接的前方加一个!格式:![中括号必须有,内容好像写什么都没关系](图片的链接 “图片下方显示的字”) No10.标记符号`，在反引号中间添加需要标记的内容我是反引号中间的内容 Tips: 在文章任意位置加 &lt;!--more--> ,只展示到该位置，保持主页整体简洁返回最上方]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 配置next主题]]></title>
    <url>%2F2018%2F11%2F20%2Fhexo-%E4%BD%BF%E7%94%A8next%E4%B8%BB%E9%A2%98%2F</url>
    <content type="text"><![CDATA[配置next主题 1、进入blog目录 2、首先通过git下载next主题 1git clone https://github.com/iissnan/hexo-theme-next themes/next 3、修改_config.yml文件 E:\test\blog 1theme: landscape 4、切换主题风格，在E:\test\blog\themes\next目录下找到_config.yml文件，修改scheme的value 1scheme: Mist 5、保存，启动hexo server，访问4000端口，测试博客是否正常访问 Tips: 启用阅读量统计,修改next配置文件_config.yml中的 leancloud_visitors字段，其中app_id和app_key需要去 https://leancloud.cn 注册配置 1234leancloud_visitors: enable: true app_id: # your leancloud application appid app_key: # your leancloud application appkey 启用评论系统，在valine配置申请号的id和key 1234567891011121314valine: enable: true appid: # your leancloud application appid appkey: # your leancloud application appkey notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: ... # comment box placeholder avatar: mm # gravatar style guest_info: nick # custom comment header pageSize: 10 # pagination size meta: nick #目前我配置好后，评论数统计一直是零，不知是哪里有问题，有踩过坑的盆友请联系我 #更新:原来我把facebook_comments_plugin配置为true了，导致冲突，把这个关闭就正常了]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Blog]]></title>
    <url>%2F2018%2F11%2F20%2Fhello-blog%2F</url>
    <content type="text"><![CDATA[Now is the time for all good men to come to the aid fo their country. 发布文章的步骤： 1、hexo new 创建文章 2、Markdown语法编辑文章 3、部署（所有执行命令都是在blog目录下） Tips:hexo clean #清除缓存 网页正常情况下可以忽略此条命令hexo generate #生成hexo server #启动服务预览，非必要，可本地浏览网页hexo deploy #部署发布]]></content>
  </entry>
</search>
